<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst PUBLIC "-//adms//DTD admst 2.0//-" "http://mot-adms.sourceforge.net/xml-files/adms/admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

  <!--
  Purpose:  Provide a basic set of ADMST templates for working on Xyce
            modules
      Creator:   Tom Russo, SNL, Electrical and Microsystems Modeling
      Creation Date: 8 May 2008

 Copyright Notice

   Copyright 2002 Sandia Corporation. Under the terms
   of Contract DE-AC04-94AL85000 with Sandia Corporation, the U.S.
   Government retains certain rights in this software.

    Xyce(TM) Parallel Electrical Simulator
    Copyright (C) 2002-2017 Sandia Corporation

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>

   =================================================================-
   =================================================================-
    simple templates for producing commonly-used information
   =================================================================-
   =================================================================-
  -->

  <!--
   =================================================================-
   xyceNumberNodes
    return the number of nodes (internal and external)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberNodes">
    <admst:text format="%(count(node[grounded='no']))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberProbes
    return the number of nodes (internal and external)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberProbes">
    <admst:text format="%(count(probe)+count(@extraProbeBranches))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberInternalNodes
    return the number of nodes (internal)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberInternalNodes">
    <admst:text format="%(count(node[grounded='no' and location='internal']))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberExternalNodes
    return the number of nodes (External)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberExternalNodes">
    <admst:text format="%(count(node[grounded='no' and location='external']))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberLeadCurrents
    return the number of lead currents needed
   =================================================================-
  -->
  <admst:template match="xyceNumberLeadCurrents">
    <admst:choose>
      <admst:when test="[count(node[grounded='no' and location='external']) = 2 ]">
        <admst:text format="1"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="%(count(node[grounded='no' and location='external']))"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   xyceDeviceNamespace
    Given a module, return what Xyce namespace we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceDeviceNamespace">
    <admst:return name="classname" value="ADMS%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceClassBaseName
    Given a module, return what Xyce class we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceClassBaseName">
    <admst:return name="classname" value="N_DEV_ADMS%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceInstanceClassName
    Given a module, return what Xyce class we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceInstanceClassName">
    <admst:return name="classname" value="N_DEV_ADMS%(name)Instance"/>
  </admst:template>

  <!--
   =================================================================-
   xyceModelClassName
    Given a module, return what Xyce class we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceModelClassName">
    <admst:return name="classname" value="N_DEV_ADMS%(name)Model"/>
  </admst:template>

  <!--
   =================================================================-
   xyceGuardSymbol: make a symbol for the header file to use to prevent
   multiple inclusion
   =================================================================-
  -->
  <admst:template match="xyceGuardSymbol">
    <admst:return name="symbolname" value="Xyce_N_DEV_ADMS%(name)_h"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNodeConstantName
    given a node, generate the name of the integer symbol used to
    identify it in Xyce
   =================================================================-
  -->
  <admst:template match="xyceNodeConstantName">
    <admst:return name="nodeConstant" value="admsNodeID_%(name)"/>
  </admst:template>
  <!--
   =================================================================-
   xyceBranchConstantName
    given a branch, generate the name of the integer symbol used to
    identify it in Xyce
   =================================================================-
  -->
  <admst:template match="xyceBranchConstantName">
    <admst:return name="branchConstant" value="admsBRA_ID_%(pnode)_%(nnode)"/>
  </admst:template>


  <!--
   =================================================================-
   xyceProbeConstantName
    given a probe, generate the name of the integer symbol used to
    identify it in Xyce
   =================================================================-
  -->
  <admst:template match="xyceProbeConstantName">
    <admst:return name="probeConstant" value="admsProbeID_%(nature)_%(branch/pnode)_%(branch/nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xycePotentialProbeConstantName
    given a branch, generate the name of the integer symbol used to
    identify its associated potetial probe constant in Xyce
   =================================================================-
  -->
  <admst:template match="xycePotentialProbeConstantName">
    <admst:return name="probeConstant" value="admsProbeID_V_%(pnode)_%(nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceFlowProbeConstantName
    given a branch, generate the name of the integer symbol used to
    identify it's associated flow probe in Xyce
   =================================================================-
  -->
  <admst:template match="xyceFlowProbeConstantName">
    <admst:return name="probeConstant" value="admsProbeID_I_%(pnode)_%(nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceJacobianOffsetName
    given a jacobian element, generate the name of the integer symbol
    used to identify its offset
   =================================================================-
  -->
  <admst:template match="xyceJacobianOffsetName">
    <admst:text format="A_%(row/name)_Equ_%(column/name)_NodeOffset"/>
  </admst:template>

  <!--
   =================================================================-
   xycedFdXPtrName
    given a jacobian element, generate the name of the pointer var
    used to identify its location
   =================================================================-
  -->
  <admst:template match="xycedFdXPtrName">
    <admst:text format="f_%(row/name)_Equ_%(column/name)_Node_Ptr"/>
  </admst:template>
  <!--
   =================================================================-
   xycedQdXPtrName
    given a jacobian element, generate the name of the pointer var
    used to identify its location
   =================================================================-
  -->
  <admst:template match="xycedQdXPtrName">
    <admst:text format="q_%(row/name)_Equ_%(column/name)_Node_Ptr"/>
  </admst:template>

  <!--
   =================================================================-
    xyceDeclareVariable
    Given a variable, emit a C++ declaration for that variable
   =================================================================-
  -->
  <admst:template match="xyceDeclareVariable">
    <admst:assert test="adms[datatypename='variable' or datatypename='variableprototype']" format="xyceDeclareVariable expecting datatypename=variable or variableprototype, got %(adms/datatypename)"/>
    <admst:choose>
      <admst:when test="[type='real' and exists(probe) and not($globalCurrentScope='sensitivity')]">
        <admst:text format="AdmsFadType"/>
      </admst:when>
      <!-- Bah.  Looks like "variable" dependency doesn't get propagated past
           one level.

           Tried having  and exists(variable[input='yes']) here, and it
           seems to have missed some.  So we have to make ALL reals in
           sensitivity be FADS
      -->
      <admst:when test="[type='real' and $globalCurrentScope='sensitivity' and exists(#Pdependent)]">
        <admst:text format="AdmsSensFadType"/>
      </admst:when>
      <admst:otherwise>
        <admst:apply-templates select="." match="verilog2CXXtype"/>
      </admst:otherwise>
    </admst:choose>
    <admst:text format=" %(name);\n"/>
  </admst:template>

  <!--
   =================================================================-
   =================================================================-
    Specialized templates for dealing with guessing device model cards
    and/or header files to include
   =================================================================-
   -->

   <!--
   =================================================================-
   xyceIncludeModelBaseHeader
   Given a module, this template generates an appropriate "#include"
   for the base device IF the module has a "xyceModelGroup" attribute.
   If the attribute doesn't exist, no include is generated.

   Recognized groups:        Header included:
      MOSFET                  N_DEV_MOSFET1.h
      <anything else>         N_DEV_<that>.h
   =================================================================-
   -->
   <admst:template match="xyceIncludeModelBaseHeader">
     <admst:choose>
       <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
         <admst:choose>
           <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
             <admst:text format="#include &lt;N_DEV_MOSFET1.h&gt;\n"/>
           </admst:when>
           <admst:otherwise>
             <admst:text format="#include &lt;N_DEV_%(attribute[name='xyceModelGroup']/value).h&gt;\n"/>
           </admst:otherwise>
         </admst:choose>
       </admst:when>
     </admst:choose>
   </admst:template>

   <!--
   =================================================================-
   xyceDeclareTraits
   Given a module, this template generates an appropriate "typedef"
   for the DeviceTraits.  IF the module has a "xyceModelGroup" attribute,
   then this uses the base group instance as the group in the template.
   If the attribute doesn't exist, no base group is used.

   Recognized groups:        Base instance:
      MOSFET                  MOSFET1
      <anything else>         <verbatim>
   =================================================================-
   -->
   <admst:template match="xyceDeclareTraits">
struct Traits: public DeviceTraits&lt;Model, Instance
     <admst:choose>
       <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
         <admst:choose>
           <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
             <admst:text format=", MOSFET1::Traits"/>
           </admst:when>
           <admst:otherwise>
             <admst:text format=", %(attribute[name='xyceModelGroup']/value)::Traits"/>
           </admst:otherwise>
         </admst:choose>
       </admst:when>
     </admst:choose>&gt;
{

    <!-- Figure out a level number -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceLevelNumber'])]">
        <admst:variable name="theLevelNumber" select="%(attribute[name='xyceLevelNumber']/value)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theLevelNumber" select="1"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Choose a device name -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceDeviceName'])]">
        <admst:variable name="theDeviceName" select="%(attribute[name='xyceDeviceName']/value)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theDeviceName" select="ADMS %(name)"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Figure out what spice symbol we use -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceSpiceDeviceName'])]">
        <admst:variable name="theSpiceDevice" select="%(attribute[name='xyceSpiceDeviceName']/value)"/>
      </admst:when>
      <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
        <admst:choose>
          <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
            <admst:variable name="theSpiceDevice" select="m"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
            <admst:variable name="theSpiceDevice" select="q"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Diode']">
            <admst:variable name="theSpiceDevice" select="d"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Resistor']">
            <admst:variable name="theSpiceDevice" select="r"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Capacitor']">
            <admst:variable name="theSpiceDevice" select="c"/>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theSpiceDevice" select="%(.)"/>
      </admst:otherwise>
    </admst:choose>

    <admst:text format="  static const char *name() {return &quot;%($theDeviceName)&quot;;}\n"/>
    <admst:text format="  static const char *deviceTypeName() {return &quot;%($theSpiceDevice) level %($theLevelNumber)&quot;;}\n"/>
  static int numNodes() {return <admst:text format="%(xyceNumberExternalNodes(.))"/>;}
  static bool modelRequired() {return
     <admst:choose>
       <admst:when test="variable[parametertype='model' and input='yes']">
         <admst:text format="true"/>
       </admst:when>
       <admst:otherwise>
         <admst:text format="false"/>
       </admst:otherwise>
     </admst:choose>
     <admst:text format=";}"/>
  static bool isLinearDevice() {return false;}

  static Device *factory(const Configuration &amp;configuration, const FactoryBlock &amp;factory_block);
  static void loadModelParameters(ParametricData&lt;Model&gt; &amp;model_parameters);
  static void loadInstanceParameters(ParametricData&lt;Instance&gt; &amp;instance_parameters);
};
   </admst:template>

  <!--
   =================================================================-
   xyceDeviceFactoryandRegisterDevice

   Given a module, this template generates appropriate code for a
   device factory and registerDevice method.  If the attribute
   xyceDeviceName exists, we use that as the name of the device.  If
   not, we use "ADMS <module name>".  Other expected attributes are:

      xyceSpiceDeviceName:   if not given, guess at one from xyceModelGroup.
                             If that is not given, emit a "FIXME"
      xyceLevelNumber:       If not given, "FIXME"

   -->
  <admst:template match="xyceDeviceFactoryandRegisterDevice">

    <!-- Figure out what spice symbol we use -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceSpiceDeviceName'])]">
        <admst:variable name="theSpiceDevice" select="%(attribute[name='xyceSpiceDeviceName']/value)"/>
      </admst:when>
      <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
        <admst:choose>
          <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
            <admst:variable name="theSpiceDevice" select="m"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
            <admst:variable name="theSpiceDevice" select="q"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Diode']">
            <admst:variable name="theSpiceDevice" select="d"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Resistor']">
            <admst:variable name="theSpiceDevice" select="r"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Capacitor']">
            <admst:variable name="theSpiceDevice" select="c"/>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theSpiceDevice" select="%(.)"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Figure out a level number -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceLevelNumber'])]">
        <admst:variable name="theLevelNumber" select="%(attribute[name='xyceLevelNumber']/value)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theLevelNumber" select="1"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Now emit the factory -->
    <admst:text format="Device *Traits::factory(const Configuration &amp;configuration, const FactoryBlock &amp;factory_block)\n"/>
    <admst:text format="{\n"/>
    <admst:text format="  return new DeviceMaster&lt;Traits&gt;(configuration, factory_block, factory_block.solverState_, factory_block.deviceOptions_);\n"/>
    <admst:text format="}\n\n"/>

    <!-- and the registerDevice -->
    <admst:text format="void registerDevice()\n"/>
    <admst:text format="{\n"/>
    <admst:text format="  Config&lt;Traits&gt;::addConfiguration()\n"/>
    <admst:text format="    .registerDevice(&quot;%($theSpiceDevice)&quot;, %($theLevelNumber))"/>

    <!-- and all the registerModelTypes... -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceModelCardType'])]">
        <admst:for-each select="attribute[name='xyceModelCardType']">
          <admst:text format="\n    .registerModelType(&quot;%(./value)&quot;, %($theLevelNumber))"/>
        </admst:for-each>
      </admst:when>
      <admst:otherwise>
        <admst:choose>
          <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
            <admst:choose>
              <admst:when  test="[attribute[name='xyceModelGroup']/value='MOSFET']">
                <admst:text format="\n    .registerModelType(&quot;nmos&quot;, %($theLevelNumber))"/>
                <admst:text format="\n    .registerModelType(&quot;pmos&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
                <admst:text format="\n    .registerModelType(&quot;npn&quot;, %($theLevelNumber))"/>
                <admst:text format="\n    .registerModelType(&quot;pnp&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Diode']">
                <admst:text format="\n    .registerModelType(&quot;d&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Resistor']">
                <admst:text format="\n    .registerModelType(&quot;r&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Capacitor']">
                <admst:text format="\n    .registerModelType(&quot;c&quot;, %($theLevelNumber))"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <!-- If the device requires a model (i.e. there are any
                  parameters of type "model"), and no modely type has
                  been given in attributes, emit comments to fix the issue -->
            <admst:if test="variable[(parametertype='model' and input='yes') or (parametertype='instance' and exists(attribute/[name='xyceAlsoModel']) and input='yes')]">

                <admst:text format="\n    .registerModelType(&quot;%($theSpiceDevice)&quot;, %($theLevelNumber))\n"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>

    <admst:text format=";\n}\n\n"/>

  </admst:template>


  <!--
   =================================================================-
   xyceSetTypeVariable

   If the module defines a xyceModelGroup AND a non-null xyceTypeVariable,
   emit the hackish code that sets the type variable based on the model
   card type.

   Input type is a module.
   =================================================================-
  -->
  <admst:template match="xyceSetTypeVariable">
    <admst:if test="[exists(attribute[name='xyceModelGroup']) and (attribute[name='xyceModelGroup']/value='MOSFET' or attribute[name='xyceModelGroup']/value='BJT')]">
      <admst:variable name="Ptype" value="-1"/>
      <admst:if test="[exists(attribute[name='xycePTypeValue']) and attribute[name='xyceTypePtypeValue']/value != '']">
        <admst:variable name="Ptype" value="%(attribute[name='xycePTypeValue']/value)"/>
      </admst:if>
      <admst:if test="[exists(attribute[name='xyceTypeVariable']) and attribute[name='xyceTypeVariable']/value != '']">
        <admst:text format="\n// set internal model type based on model card type\n"/>
        <admst:choose>
          <admst:when  test="[attribute[name='xyceModelGroup']/value='MOSFET']">
            <admst:text format="if (getType() == &quot;pmos&quot; || getType() == &quot;PMOS&quot;)\n"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
            <admst:text format="if (getType() == &quot;pnp&quot; || getType() == &quot;PNP&quot;)\n"/>
          </admst:when>
        </admst:choose>
        <admst:text format="    %(attribute[name='xyceTypeVariable']/value) = %($Ptype);\n"/>
      </admst:if>
    </admst:if>
  </admst:template>


  <!--
   =================================================================-
   =================================================================-
    Specialized templates for declaring and initializing Instance and
    Model variables
   =================================================================-

   =================================================================-
   xyceDeclareInstanceVariables
   Extract all the variables that are either instance parameters or
   instance variables (with "global_instance" scope) and declare them
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareInstanceVariables">
    <admst:text format="    // Begin verilog Instance Variables\n"/>
    <admst:text format="    //   Instance Parameters\n"/>
    <admst:for-each select="variable[parametertype='instance' and input='yes']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="verilog2CXXtype"/>
      <admst:text format=" %(name);\n"/>
    </admst:for-each>
    <admst:text format="    //  Variables of global_instance scope\n"/>
    <admst:for-each select="variable[scope='global_instance' and input='no']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
    </admst:for-each>
    <admst:text format="    // end verilog Instance Variables=====\n"/>
  </admst:template>


  <!--
   =================================================================-
   xyceDeclareNodeConstants
    Declare const integers giving the node number of all named nodes
   =================================================================-
  -->
  <admst:template match="xyceDeclareNodeConstants">
    <admst:text format="   // node numbers\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:text format="    static const int %(xyceNodeConstantName(.)/[name='nodeConstant']/value) = %(position(.)-1);\n"/>
    </admst:for-each>
    <admst:text format="    static const int admsNodeID_GND = -1;\n"/>
    <admst:text format="   // end node numbers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareBranchConstants
    Declare const integers giving the node number of all named nodes
   =================================================================-
  -->
  <admst:template match="xyceDeclareBranchConstants">
    <admst:text format="   // Additional IDs for branch equations\n"/>
    <admst:for-each select="/module/@extraUnknowns">
      <admst:text format="    static const int %(xyceBranchConstantName(.)/[name='branchConstant']/value) = %(position(.)-1 + count(/module/node[grounded='no']));\n"/>
    </admst:for-each>
    <admst:text format="   // end branch numbers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareProbeConstants
    Declare const integers giving the probe number of all used probes
   =================================================================-
  -->
  <admst:template match="xyceDeclareProbeConstants">
    <admst:text format="   // Probe numbers\n"/>
    <admst:for-each select="$thisModule/probe">
      <admst:text format="    static const int %(xyceProbeConstantName(.)/[name='probeConstant']/value) = %(position(.)-1);\n"/>
    </admst:for-each>
    <admst:for-each select="@extraProbeBranches">
      <admst:text format="    static const int %(xyceFlowProbeConstantName(.)/[name='probeConstant']/value) = %(count($thisModule/probe)+position(.)-1);\n"/>
    </admst:for-each>
    <admst:text format="   // end probe numbers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareLimitedProbeStoreLIDs
    Declare integers for store LIDs of limited probes, given a module
   =================================================================-
  -->
  <admst:template match="xyceDeclareLimitedProbeStoreLIDs">
    <admst:text format="   // Store LIDs\n"/>
    <admst:for-each select="@limitedProbes">
      <admst:text format="    int %(xyceLimitedProbeStoreLIDVariable(.));\n"/>
    </admst:for-each>
    <admst:text format="   // end store LIDs\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceInstanceInitializers
   Extract all the variables that are either instance parameters or
   instance variables (with "global_instance" scope) and generate
   an initializer list for the constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceInstanceInitializers">
    <admst:if test="[exists(variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)("/>
      <admst:choose>
        <admst:when test="[exists(default) and not exists(#dependent)]">
          <admst:text format="%(printTerm(default))"/>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[type='real']">
              <admst:text format="0.0"/>
            </admst:when>
            <admst:when test="[type='integer']">
              <admst:text format="0"/>
            </admst:when>
            <admst:when test="[type='string']">
              <admst:text format="&quot;&quot;"/>
            </admst:when>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:text format=")"/>
    </admst:join>
    <!-- now initialize the LIDs: -->
    <admst:if test="[exists(node[grounded='no'])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="node[grounded='no']" separator=",\n    ">
      <admst:text format="%(xyceNodeLIDVariable(.))(-1)"/>
    </admst:join>
    <admst:if test="[exists(@extraUnknowns)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="@extraUnknowns" separator=",\n    ">
      <admst:text format="%(xyceBranchLIDVariable(.))(-1)"/>
    </admst:join>
    <admst:text format=",\n    "/>
    <admst:choose>
      <admst:when test="[count($theModule/node[grounded='no' and location='external']) = 2 ]">
        <admst:text format="%(xyceLeadBranchLIDVariable(node[2]))(-1)"/>
      </admst:when>
      <admst:otherwise>
        <admst:join select="node[grounded='no' and location='external']" separator=",\n    ">
          <admst:text format="%(xyceLeadBranchLIDVariable(.))(-1)"/>
        </admst:join>
      </admst:otherwise>
    </admst:choose>
    <!-- now initialize the jacobian pointers: -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedFdXPtrName(.))(0)"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(0)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <!-- for the Q jacobian -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedQdXPtrName(.))(0)"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(0)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <!-- now initialize the jacobian offsets: -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xyceJacobianOffsetName(.))(-1)"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="A_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset(-1)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Offset(-1)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Offset(-1)"/>
      </admst:join>
    </admst:for-each>
    <admst:text format=",\n    admsTemperature(getDeviceOptions().temp.getImmutableValue&lt;double&gt;())\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceModelInitializers
   Extract all the variables that are either model parameters or
   model variables (with "global_model" scope) and generate
   an initializer list for the constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceModelInitializers">
    <admst:if test="[exists(variable[((parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes') or (scope='global_model' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[((parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes') or (scope='global_model' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)("/>
      <admst:choose>
        <admst:when test="[exists(default) and not exists(#dependent)]">
          <admst:text format="%(printTerm(default))"/>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[type='real']">
              <admst:text format="0.0"/>
            </admst:when>
            <admst:when test="[type='integer']">
              <admst:text format="0"/>
            </admst:when>
            <admst:when test="[type='string']">
              <admst:text format="&quot;&quot;"/>
            </admst:when>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:text format=")"/>
    </admst:join>
  </admst:template>

  <!--
   =================================================================-
   xyceInstanceCopyInitializers
   Extract all the variables that are either instance parameters or
   instance variables (with "global_instance" scope) and generate
   an initializer list for the copy constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceInstanceCopyInitializers">
    <admst:if test="[exists(variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)(right.%(name))"/>
    </admst:join>
    <!-- now initialize the LIDs: -->
    <admst:if test="[exists(node[grounded='no'])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="node[grounded='no']" separator=",\n    ">
      <admst:text format="%(xyceNodeLIDVariable(.))(right.%(xyceNodeLIDVariable(.)))"/>
    </admst:join>
    <!-- now initialize the jacobian offsets: -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedFdXPtrName(.))(right.%(xycedFdXPtrName(.)))"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(right.f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(right.f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(right.f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <!-- same for Q -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedQdXPtrName(.))(right.%(xycedQdXPtrName(.)))"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(right.q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(right.q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(right.q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <admst:text format=",\n    admsTemperature(right.admsTemperature)\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceModelCopyInitializers
   Extract all the variables that are either model parameters or
   model variables (with "global_model" scope) and generate
   an initializer list for the copy constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceModelCopyInitializers">
    <admst:if test="[exists(variable[((parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes') or (scope='global_model' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[((parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes') or (scope='global_model' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)(right.%(name))"/>
    </admst:join>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareModelVariables
   Extract all the variables that are either model parameters or
   model variables (with "global_model" scope) and declare them.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareModelVariables">
    <admst:text format="// Begin verilog Model Variables\n"/>
    <admst:text format="//   Model Parameters\n"/>
    <admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="verilog2CXXtype"/>
      <admst:text format=" %(name);\n"/>
    </admst:for-each>
    <admst:text format="    //  Variables of global_model scope\n"/>
    <admst:for-each select="variable[scope='global_model' and input='no']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
      <admst:if test="[type='real' and exists(probe)]">
        <admst:warning format="WARNING!  global model variable %(name) has probe dependence.  That smells like an error.\n"/>
      </admst:if>
    </admst:for-each>
    <admst:text format="    // end verilog model variables====="/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareNodeLIDVariables
   Generate a set of declarations for LID variables given module's
   nodes.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareNodeLIDVariables">
    <admst:text format="    // Nodal LID Variables\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:text format="    int %(xyceNodeLIDVariable(.));\n"/>
    </admst:for-each>
    <admst:text format="    // end Nodal LID Variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareBranchLIDVariables
   Generate a set of declarations for LID variables given module's
   branch equations.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareBranchLIDVariables">
    <admst:text format="    // Branch LID Variables\n"/>
    <admst:for-each select="@extraUnknowns">
      <admst:text format="    int %(xyceBranchLIDVariable(.));\n"/>
    </admst:for-each>
    <admst:text format="    // end Branch LID Variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareLeadBranchLIDVariables
   Generate a set of declarations for LID variables given module's
   branch equations.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareLeadBranchLIDVariables">
    <admst:text format="    // Lead (branch) LID Variables\n"/>

    <!-- two-terminal devices are special, we only use one of the
         two possible lead currents, the first one. -->
    <admst:choose>
      <admst:when test="[count(node[grounded='no' and location='external']) = 2 ]">
        <!-- The first node is always GND -->
        <admst:text format="    int %(xyceLeadBranchLIDVariable(node[2]));\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:for-each select="node[grounded='no' and location='external']">
          <admst:text format="    int %(xyceLeadBranchLIDVariable(.));\n"/>
        </admst:for-each>
      </admst:otherwise>
    </admst:choose>
    <admst:text format="    // end Lead (branch) LID Variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareJacobianOffsets
   given a module, declare the batch of Offset variables used when
   accessing jacobian elements
   =================================================================-
  -->
  <admst:template match="xyceDeclareJacobianOffsets">
    <admst:text format="    // Jacobian  pointers\n"/>
    <!-- normal jacobian pointers -->
    <admst:for-each select="jacobian">
      <admst:text format="    double * %(xycedFdXPtrName(.));\n"/>
    </admst:for-each>
    <!-- extra pointers for columns from branch equation dependencies -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:for-each select="@branchDeps">
        <admst:text format="    double * f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr;\n"/>
      </admst:for-each>
    </admst:for-each>
    <!-- extra pointers for branch equation rows -->
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:for-each select="@nodeDeps">
        <admst:text format="    double * f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr;\n"/>
      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="    double * f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr;\n"/>
      </admst:for-each>
    </admst:for-each>

    <!-- now the same thing for Q -->
    <admst:for-each select="jacobian">
      <admst:text format="    double * %(xycedQdXPtrName(.));\n"/>
    </admst:for-each>
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:for-each select="@branchDeps">
        <admst:text format="    double * q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr;\n"/>
      </admst:for-each>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
        <admst:for-each select="@nodeDeps">
          <admst:text format="    double * q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr;\n"/>
        </admst:for-each>
        <admst:for-each select="@branchDeps">
          <admst:text format="    double * q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr;\n"/>
        </admst:for-each>
    </admst:for-each>
    <admst:text format="    // Jacobian offsets\n"/>
    <!-- normal jacobian pointers -->
    <admst:for-each select="jacobian">
      <admst:text format="    int %(xyceJacobianOffsetName(.));\n"/>
    </admst:for-each>
    <!-- extra pointers for columns from branch equation dependencies -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:for-each select="@branchDeps">
        <admst:text format="    int A_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset;\n"/>
      </admst:for-each>
    </admst:for-each>
    <!-- extra pointers for branch equation rows -->
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:for-each select="@nodeDeps">
        <admst:text format="    int A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Offset;\n"/>
      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="    int A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Offset;\n"/>
      </admst:for-each>
    </admst:for-each>

    <admst:text format="    // end of Jacobian and pointers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareFadArrays
   Given a module, generate declaration of contribution arrays
   =================================================================-
  -->
  <admst:template match="xyceDeclareFadArrays">
    <admst:text format=" // Arrays to hold probes\n"/>
    <admst:text format=" std::vector &lt; AdmsFadType &gt; probeVars;\n"/>
    <admst:text format=" // Arrays to hold contributions\n"/>
    <admst:text format=" // dynamic contributions are differentiated w.r.t time\n"/>
    <admst:text format=" std::vector &lt; AdmsFadType &gt; staticContributions;\n"/>
    <admst:text format=" std::vector &lt; AdmsFadType &gt; dynamicContributions;\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareLimitingTemporaries
   Declare the various temporary variables that we need for limiting
   in updateIntermediateVarsBlock.  Pass in the module.
   =================================================================-
  -->
  <admst:template match="xyceDeclareLimitingTemporaries">
    <admst:text format=" // temporary variables for limiting\n"/>
    <admst:for-each select="@limiters">
      <admst:text format=" double %(printTerm(lhs))_orig,%(printTerm(lhs))_limited,%(printTerm(lhs))_old;\n"/>
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   xyceNodeLIDVariable
   Given a node, return its associated LID variable
   =================================================================-
  -->
  <admst:template match="xyceNodeLIDVariable">
    <admst:text format="li_%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceBranchLIDVariable
   Given a branch, return its associated LID variable
   =================================================================-
  -->
  <admst:template match="xyceBranchLIDVariable">
    <admst:text format="li_BRA_%(pnode)_%(nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceLeadBranchLIDVariable
   Given a lead node, return its associated LID variable
   =================================================================-
  -->
  <admst:template match="xyceLeadBranchLIDVariable">
    <admst:text format="li_branch_i%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceLimitedProbeStoreLIDVariable
   Given a probe, return its associated state LID variable for limiting
   =================================================================-
  -->
  <admst:template match="xyceLimitedProbeStoreLIDVariable">
    <admst:text format="li_store_%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNoiseContributionName
   Given a contribution that has either white or flicker noise
   (and ONLY one term)
   construct a name for the noise.
   This noise name cannot just be the "name" argument of the noise
   function, because that is not guaranteed unique to the device
   (fbh has four terms named "thermal", for example)

   We will use "onoise_<type>_<posnode>_<negnode>".  If there is a name
   argument, we'll append "_<namearg" to the name.

  -->
  <admst:template match="xyceNoiseContributionName">
    <!-- first sanity check.  In this implementation, we ONLY support
         noise contributions that are simple "I(branch)<+ type_noise()"
         and cannot work with more complex RHS expressions. -->
    <admst:assert test="adms[datatypename='contribution']" format="xyceNoiseContribution called on something other than a contribution!\n"/>
    <admst:assert test="[datatypename='contribution' and (whitenoise='yes' or flickernoise='yes')]" format="xyceNoiseContribution called on contribution %(.), with no noise function!\n"/>
    <admst:assert test="[rhs/tree/datatypename='function']" format="xyceNoiseContribution called on contribution $(.) whose rhs is not a simple noise function!\n"/>
    <admst:variable name="theReturnName" select="onoise"/>
    <admst:choose>
      <admst:when test="[rhs/tree/name='white_noise']">
        <admst:variable name="theReturnName" select="%($theReturnName)_white"/>
      </admst:when>
      <admst:when test="[rhs/tree/name='flicker_noise']">
        <admst:variable name="theReturnName" select="%($theReturnName)_flicker"/>
      </admst:when>
    </admst:choose>
    <admst:variable name="theReturnName" select="%($theReturnName)_%(lhs/branch/pnode)_%(lhs/branch/nnode)"/>
    <admst:choose>
      <admst:when test="[rhs/tree/name='white_noise' and count(rhs/tree/arguments)=2]">
        <admst:return name="givenName" value="%(rhs/tree/arguments[2])"/>
      </admst:when>
      <admst:when test="[rhs/tree/name='flicker_noise' and count(rhs/tree/arguments)=3]">
        <admst:return name="givenName" value="%(rhs/tree/arguments[3])"/>
      </admst:when>
    </admst:choose>
    <admst:return name="noiseName" value="$theReturnName"/>
  </admst:template>
  <!--
   =================================================================-
   xyceAnalogFunctionDeclaration
    Given an analog function, return a declaration for putting in
    the header file.
    Unlike the way "analogfunction.xml" from the ADMS source does,
    we do NOT prefix the function with the module name, because
    we're going to make it a member function of the class, and the
    prefix will be redundant
   =================================================================-
  -->
  <admst:template match="xyceAnalogFunctionDeclaration">
    <admst:value-of select="name"/>
    <admst:variable name="function" select="%s"/>
    <admst:apply-templates
       select="."
       match="verilog2CXXtype"/>
    <admst:text format=" $function("/>
    <admst:join
       select="variable[input='yes']"
       separator=", ">
      <admst:value-of select="name"/>
      <admst:apply-templates select="." match="verilog2CXXtype"/>
      <admst:text format=" %s"/>
    </admst:join>
    <admst:text format=");\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceTemplatedAnalogFunctionDeclaration
    Given an analog function, return a declaration for putting in
    the header file.
   Unlike xyceAnalogFunctionDeclaration, we don't actually declare
   the function as it's declared in the verilog source, but rather
   as a templated function whose return type is assumed to be the
   type of all its arguments, which are assumed to be all of
   exactly the same type.  We'll simply puke with an error if this
   condition isn't met.
    Unlike the way "analogfunction.xml" from the ADMS source does,
    we do NOT prefix the function with the module name, because
    we're going to make it a member function of the class, and the
    prefix will be redundant
   =================================================================-
  -->
  <admst:template match="xyceTemplatedAnalogFunctionDeclaration">
    <admst:value-of select="name"/>
    <admst:variable name="function" select="%s"/>
    <!-- save the return type -->
    <admst:value-of select="type"/>
    <admst:variable name="returnType" select="%s"/>

    <!-- puke if any variable fails to match type -->
    <admst:for-each select="variable[input='yes' and
                            type!='$returnType']">
      <admst:fatal format="Variable %(name) of type %(type) is not of same type as return
                      type of function $function, which is of type$returnType\n"/>
    </admst:for-each>

    <!-- if we get here, all's good. Just churn out the declaration -->
    <!-- must output variables defined as input, output, or inout, but not
         the one that has the same name as the function -->
    <admst:text format="template&lt;typename ScalarT&gt; ScalarT $function("/>
    <admst:join
       select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]"
       separator=", ">
      <admst:text format="ScalarT "/>
      <!-- only pass by reference if it's an output variable. -->
      <!-- this does cost us in copy constructions of Sacado type variables,
           but is needed for correctness if analog functions modify their
           "input" variables, which they're allowed to do -->
      <admst:if test="[output='yes']">
        <admst:text format="&amp; "/>
      </admst:if>
      <admst:text format="%(name)"/>
    </admst:join>
    <admst:text format=")\n"/>
    <admst:text format="{\n"/>

    ScalarT %($function);

    <admst:for-each select="variable[input='no' and output='no']">
      <admst:text select="[type='$returnType']" format="ScalarT "/>
      <admst:text select="[type!='$returnType']" format="%(verilog2CXXtype(.)) "/>
      <admst:text format="%(name);\n"/>
    </admst:for-each>
    <admst:apply-templates select="tree" match="%(adms/datatypename)"/>
    <admst:text format="return(%(name));\n"/>
    <admst:text format="}\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceCopyModelVars
     given a module, generate code for assuring that instance vars
     that override model vars get appropriate defaults
   =================================================================-
  -->
  <admst:template match="xyceCopyModelVars">
    <admst:for-each select="variable[parametertype='instance' and exists(attribute[name='xyceAlsoModel']) and input='yes']">
      <admst:text format="   if (!(given(&quot;%(name)&quot;)))\n"/>
      <admst:text format="   {\n"/>
      <admst:text format="      %(name) = model_.%(name);\n"/>
      <admst:text format="   }\n"/>
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   xyceRegisterJacLIDs
     given a module, generate code for initializing jacobian LIDs
   =================================================================-
  -->
  <admst:template match="xyceRegisterJacLIDs">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:text format="  IntPair jacLoc;\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationNumber" select="%(position(.)-1)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(row/name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(column/name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    jacLoc = pairToJacStampMap[IntPair(%(xyceNodeConstantName(row)/[name='nodeConstant']/value),%(xyceNodeConstantName(column)/[name='nodeConstant']/value))];\n"/>
        <admst:text format="    %(xyceJacobianOffsetName(.)) = jacLIDVec[jacLoc.first][jacLoc.second];\n"/>
        <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
        <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:for-each>

      <!-- set up pointers for extra columns due to branches-->
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:variable name="theNode" select="%(.)"/>
      <admst:for-each select="@branchDeps">
        <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%($theNodeName))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    jacLoc=pairToJacStampMap[IntPair(%(xyceNodeConstantName($theNode)/[name='nodeConstant']/value),%(xyceBranchConstantName(.)/[name='branchConstant']/value))];\n"/>
        <admst:text format="    A_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Offset = jacLIDVec[jacLoc.first][jacLoc.second];\n"/>
        <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:for-each>

    </admst:for-each>

    <!-- Now we need to generate the pointers for the extra rows for branch
         equations -->
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:variable name="theBranch" select="%(.)"/>
      <admst:for-each select="@nodeDeps">
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    jacLoc = pairToJacStampMap[IntPair(%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value),%(xyceNodeConstantName(.)/[name='nodeConstant']/value))];\n"/>
        <admst:text format="    A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Offset = jacLIDVec[jacLoc.first][jacLoc.second];\n"/>
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>

      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="    jacLoc = pairToJacStampMap[IntPair(%(xyceBranchConstantName($theBranch)/[name='branchConstant']/value),%(xyceBranchConstantName(.)/[name='branchConstant']/value))];\n"/>
        <admst:text format="    A_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Offset=jacLIDVec[jacLoc.first][jacLoc.second];\n"/>
      </admst:for-each>
    </admst:for-each>
  </admst:template>


  <!--
   =================================================================-
   xyceSetupPointers
     given a module, generate code for initializing jacobian LIDs
   =================================================================-
  -->
  <admst:template match="xyceSetupPointers">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationNumber" select="%(position(.)-1)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(row/name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(column/name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    %(xycedFdXPtrName(.)) = dFdxMatPtr->returnRawEntryPointer(%(xyceNodeLIDVariable(row)),%(xyceNodeLIDVariable(column)));\n"/>
        <admst:text format="    %(xycedQdXPtrName(.)) = dQdxMatPtr->returnRawEntryPointer(%(xyceNodeLIDVariable(row)),%(xyceNodeLIDVariable(column)));\n"/>
        <admst:if test="[exists(row/#collapsible) and (row/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
        <admst:if test="[not(column=row) and exists(column/#collapsible) and (column/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:for-each>

      <!-- set up pointers for extra columns due to branches-->
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:variable name="theNode" select="%(.)"/>
      <admst:for-each select="@branchDeps">
        <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%($theNodeName))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr = dFdxMatPtr->returnRawEntryPointer(%(xyceNodeLIDVariable($theEquation)),%(xyceBranchLIDVariable(.)));\n"/>
        <admst:text format="    q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr = dQdxMatPtr->returnRawEntryPointer(%(xyceNodeLIDVariable($theEquation)),%(xyceBranchLIDVariable(.)));\n"/>
        <admst:if test="[exists($theNode/#collapsible) and ($theNode/@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>
      </admst:for-each>

    </admst:for-each>

    <!-- Now we need to generate the pointers for the extra rows for branch
         equations -->
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:variable name="theBranch" select="%(.)"/>
      <admst:for-each select="@nodeDeps">
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="if (!collapseNode_%(name))\n"/>
          <admst:text format="{\n"/>
        </admst:if>
        <admst:text format="    f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr = dFdxMatPtr->returnRawEntryPointer(%(xyceBranchLIDVariable($theBranch)),%(xyceNodeLIDVariable(.)));\n"/>
        <admst:text format="    q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr = dQdxMatPtr->returnRawEntryPointer(%(xyceBranchLIDVariable($theBranch)),%(xyceNodeLIDVariable(.)));\n"/>
        <admst:if test="[exists(#collapsible) and (@collapsesTo/name='GND')]">
          <admst:text format="}\n"/>
        </admst:if>

      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="    f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr=dFdxMatPtr->returnRawEntryPointer(%(xyceBranchLIDVariable($theBranch)),%(xyceBranchLIDVariable(.)));\n"/>
        <admst:text format="    q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr=dQdxMatPtr->returnRawEntryPointer(%(xyceBranchLIDVariable($theBranch)),%(xyceBranchLIDVariable(.)));\n"/>
      </admst:for-each>
    </admst:for-each>

  </admst:template>


  <!--
   =================================================================-
   xyceGenerateJacStamp
     given a module, generate code for initializing  jacobian stamp
   =================================================================-
  -->
  <admst:template match="xyceGenerateJacStamp">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:text format="    jacStamp.resize(%(count(node[grounded='no'])));\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:text format="    jacStamp[$theEquationConstant].resize(%(count($theModule/jacobian[row/name='$theEquationName'])+count(@branchDeps)));\n"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:text format="    jacStamp[$theEquationConstant][%(position(.)-1)] = %(xyceNodeConstantName(column)/[name='nodeConstant']/value);\n"/>
      </admst:for-each>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format="    // Extra columns for dependence on branches\n"/>
        <admst:text format="    {\n      int tempOffset=0;\n"/>
        <admst:for-each select="@branchDeps">
        <admst:text format="    jacStamp[$theEquationConstant][%(count($theModule/jacobian[row/name='$theEquationName']))+(tempOffset++)] = %(xyceBranchConstantName(.)/[name='branchConstant']/value);\n"/>
        </admst:for-each>
        <admst:text format="    }\n\n"/>
      </admst:if>

    </admst:for-each>
    <admst:apply-templates select="." match="xyceAugmentJacStamp"/>
  </admst:template>

  <!--
   =================================================================-
   xyceGenerateJacStamp2
     given a module, generate code for initializing  jacobian stamp
   =================================================================-
  -->
  <admst:template match="xyceGenerateJacStamp2">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:text format="PairVector jacobianElements;\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:text format="    jacobianElements.push_back(IntPair($theEquationConstant,%(xyceNodeConstantName(column)/[name='nodeConstant']/value)));\n"/>
      </admst:for-each>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format="    // Extra columns for dependence on branches\n"/>
        <admst:for-each select="@branchDeps">
        <admst:text format="    jacobianElements.push_back(IntPair($theEquationConstant,%(xyceBranchConstantName(.)/[name='branchConstant']/value)));\n"/>
        </admst:for-each>
      </admst:if>

    </admst:for-each>

    <admst:if test="[not(nilled(@extraUnknowns))]">
      <admst:text format="    // Jacobian rows for branch equations\n"/>
    </admst:if>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="theRow" select="%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
      <admst:variable name="theBranchName" select="%(.)"/>
      <admst:for-each select="@nodeDeps">
        <admst:text format="jacobianElements.push_back(IntPair($theRow,%(xyceNodeConstantName(.)/[name='nodeConstant']/value)));   // Branch eqn %($theBranchName) - node %(./name)\n"/>
      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="jacobianElements.push_back(IntPair($theRow,%(xyceBranchConstantName(.)/[name='branchConstant']/value))); // Branch eqn %($theBranchName) - branch var %(.)\n"/>
      </admst:for-each>
    </admst:for-each>

  </admst:template>


  <!--
   =================================================================-
   xyceAugmentJacStamp
     given a module, generate code for adding branch equations/variables
     to an existing  jacobian stamp
   =================================================================-
  -->
  <admst:template match="xyceAugmentJacStamp">

<!--
    <admst:for-each select="@extraJac1">
      <admst:variable name="theRow" select="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
      <admst:variable name="theRowName" select="%(name)"/>
      //Augment jacobian row for %($theRowName)
    {
      int rowsize;
      int tempColOffset=0;
      rowsize=jacStamp[%($theRow)].size();
      jacStamp[%($theRow)].resize(rowsize+%(count(@branchDeps)));
      <admst:for-each select="@branchDeps">
      jacStamp[%($theRow)][rowsize+(tempColOffset++)] = %(xyceBranchConstantName(.)/[name='branchConstant']/value); // eqn %($theRowName) - branch var %(.)
      </admst:for-each>
    }
    </admst:for-each>
-->
    <admst:if test="[not(nilled(@extraUnknowns))]">
      <admst:text format="    // Jacobian rows for branch equations\n"/>
    </admst:if>
    <admst:for-each select="@extraUnknowns">
    {
      int jacsize=jacStamp.size();
      jacStamp.resize(jacsize+1);
      <admst:variable name="theRow" select="%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
      <admst:variable name="theBranchName" select="%(.)"/>
      jacStamp[$theRow].resize(%(count(@nodeDeps)+count(@branchDeps)));
      int tempCol = 0;
      <admst:for-each select="@nodeDeps">
      jacStamp[$theRow][tempCol++] = %(xyceNodeConstantName(.)/[name='nodeConstant']/value);   // Branch eqn %($theBranchName) - node %(./name)
      </admst:for-each>
      <admst:for-each select="@branchDeps">
      jacStamp[$theRow][tempCol++] = %(xyceBranchConstantName(.)/[name='branchConstant']/value); // Branch eqn %($theBranchName) - branch var %(.)
      </admst:for-each>
    }
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   xyceLabelNoiseContributions
   Add a "#noiseContIndex" variable to each contribution that has
   noise.  This will be used later to index into a vector of
   contributions.
   The thing passed in should be a module.
   =================================================================-
  -->
  <admst:template match="xyceLabelNoiseContributions">
    <admst:for-each select="contribution[whitenoise='yes' or flickernoise='yes']">
      <admst:value-to select="#noiseContIndex" value="%(position(.)-1)"/>
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   collectBranchDepends
   Given a branch (which is assumed to have an associated
   branch variable due to use of flow probes and/or potential sources),
   count up how many jacobian columns should be allocated for the
   associated branch equation.  When returns, /module/@countNodes
   will list all the nodes this branch equation depends on (through
   potential probes) and /module/@countBranches will list the branch
   flows it depends on (through flow probes).
   =================================================================-
   -->
  <admst:template match="collectBranchDepends">
    <admst:variable name="thePnode" select="%(pnode)"/>
    <admst:variable name="theNnode" select="%(nnode)"/>
    <admst:reset select="/module/@countNodes"/>
    <admst:reset select="/module/@countBranches"/>
    <admst:for-each select="/module/contribution[lhs/branch/pnode=$thePnode and lhs/branch/nnode=$theNnode]">
      <admst:for-each select="rhs/probe">
        <admst:choose>
          <!-- potential probes on the RHS add nodal dependencies to
               the branch equation-->
          <admst:when test="[nature=discipline/potential]">
            <admst:push into="/module/@countNodes" select="branch/pnode" onduplicate="ignore"/>
            <admst:if test="[branch/nnode/grounded='no']">
              <admst:push into="/module/@countNodes" select="branch/nnode" onduplicate="ignore"/>
            </admst:if>
          </admst:when>
          <!-- flow probes on the RHS add branch dependencies to the
               branch equation -->
          <admst:otherwise>
            <admst:push into="/module/@countBranches" select="branch" onduplicate="ignore"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
      <!-- Finally, if this is a potential source, the branch equation
           also depends on the nodes of the lhs.  If it's a flow source,
           the branch equation depends on the flow variable.
      -->
      <admst:choose>
        <admst:when test="[lhs/nature=lhs/discipline/potential]">
          <admst:push into="/module/@countNodes" select="lhs/branch/pnode" onduplicate="ignore"/>
          <admst:if test="[lhs/branch/nnode/grounded='no']">
            <admst:push into="/module/@countNodes" select="lhs/branch/nnode" onduplicate="ignore"/>
            </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:push into="/module/@countBranches" select="lhs/branch" onduplicate="ignore"/>
        </admst:otherwise>
      </admst:choose>

    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   =================================================================-
   Basic templates for processing verilog

   =================================================================-
   =================================================================-

   =================================================================-
   collectAssignedVariables
   Given a node of the ADMS data tree, determine all variables that
   appear on the left-hand side of assignments in that node and all
   of its children.  This is done recursively.

   The list of all those variables is deposited in the @assignedVars
   array of the *PARENT* of the node passed in.  This is fishy, and
   I wish I could figure out a way to do it without pushing the data
   up above the node we start with.

   Since we push data upward, it's probably best not to call this on
   the top level "analog/code" node of the tree, but rather loop over
   all of that node's children instead if one needs to process it.
   =================================================================-
  -->
<admst:template match="collectAssignedVariables">
  <admst:choose>
    <!-- ASSIGNMENT -->
    <admst:when test="adms[datatypename='assignment']">
      <admst:push into="../@assignedVars" select="lhs" onduplicate="ignore"/>
    </admst:when>
    <!-- BLOCK -->
    <admst:when test="adms[datatypename='block']">
      <!-- recurse -->
      <admst:for-each select="item">
        <admst:apply-templates select="." match="collectAssignedVariables"/>
      </admst:for-each>
      <!-- the result should be that our current node, which is a block,
           has received all the variables of all its children listed in
           @assignedVars -->
    </admst:when>
    <!-- CONDITIONAL -->
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="then" match="collectAssignedVariables"/>
      <admst:apply-templates select="else" match="collectAssignedVariables"/>
    </admst:when>
    <!-- WHILELOOP -->
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="collectAssignedVariables"/>
    </admst:when>
    <!-- FORLOOP -->
    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="initial" match="collectAssignedVariables"/>
      <admst:apply-templates select="forblock" match="collectAssignedVariables"/>
      <admst:apply-templates select="update" match="collectAssignedVariables"/>
    </admst:when>
    <!-- CASE -->
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="caseitem" match="collectAssignedVariables"/>
    </admst:when>
    <!-- caseitem -->
    <admst:when test="adms[datatypename='caseitem']">
      <admst:apply-templates select="code" match="collectAssignedVariables"/>
    </admst:when>
    <!-- CODE -->
    <admst:when test="adms[datatypename='code']">
      <admst:apply-templates select="item" match="collectAssignedVariables">
      </admst:apply-templates>
    </admst:when>
    <!-- none of the following types can do assignment -->
    <admst:when test="adms[datatypename='contribution']"/>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="'datatypename=%(adms/datatypename)':collectAssignedVariables cannot process this type, should not be reached.\n"/>
    </admst:otherwise>
  </admst:choose>
  <!-- At this point, we have processed our own and our children's variables,
       and our @assignedVars array contains all the variables we or our
       children have assigned into.  Pass this information up to our parent
       if we haven't already done it (because we're an assignment). -->
  <admst:if test="adms[datatypename!='assignment']">
    <admst:variable name="parent" select="%(..)"/>
    <admst:for-each select="@assignedVars">
      <!--<admst:message format="Got something other than assignment (%(../datatypename)), pushing %(.) into parent which is of type %($parent/datatypename)\n"/>-->
      <admst:variable name="thisName" value="%(name)"/>
      <!-- not enough to push with 'onduplicate="ignore"' because the actual
           variable node has more info than just the name, and different
           instances aren't actually duplicates just because the name is the
           same. This would result in multiple declarations if we're not
           careful. -->
      <admst:if test="[not exists($parent/@assignedVars[name=$thisName])]">
        <admst:push into="$parent/@assignedVars" select="." onduplicate="ignore"/>
      </admst:if>
    </admst:for-each>
  </admst:if>
</admst:template>

<!--
 =================================================================-
 collectInterdependentParams
 Given a module, run through all the parameter variables it has and
 mark as "#dependent='yes'" any that have default values that depend
 on other variables in any way.

 These variables cannot have their defaults determined by their addPar
 calls, and must have their defaults set (if not given in the netlist)
 at constructor time instead.

 This template is intended to be called early in processing, like
 collectLimters and collectCollapsibles
 =================================================================-
 -->
 <admst:template match="collectInterdependentParams">
   <admst:for-each select="variable[(parametertype='instance' or parametertype='model') and input='yes' and exists(default)]">
     <admst:apply-templates select="default" match="recursiveDetectVariableDependence">
       <admst:if test="[returned('isDependent')/value = 'yes']">
         <admst:value-to select="../#dependent" string="yes"/>
       </admst:if>
     </admst:apply-templates>
   </admst:for-each>
 </admst:template>

<!--
 =================================================================-
 collectParamDependence
 Given a variable, run through everything it depends on, and check
 if it depends on any parameters

This is necessary because ADMS only stores parameter dependence
that is explicit.   Parameter dependence that is inherited from
other variables does not get propagated into a variable's
"variarable" structure
 =================================================================-
 -->
 <admst:template match="collectParamDependence">
   <admst:variable name="isDependent" value="no"/>
   <admst:apply-templates select="." match="recursiveDetectParameterDependence">
     <admst:if test="[returned('isDependent')/value = 'yes']">
       <admst:value-to select="#Pdependent" string="yes"/>
     </admst:if>
   </admst:apply-templates>
 </admst:template>

<!--
 =================================================================-
 recursiveDetectVariableDependence
 Given a node, try to determine if the expression it represents has
 dependence on any variables
 =================================================================-
 -->
 <admst:template match="recursiveDetectVariableDependence">
 <admst:choose>
   <admst:when test="[datatypename='number']">
     <admst:return name="isDependent" value="no"/>
   </admst:when>
   <admst:when test="[datatypename='variable']">
     <admst:return name="isDependent" value="yes"/>
   </admst:when>
   <admst:when test="[datatypename='expression']">
     <admst:apply-templates select="tree" match="recursiveDetectVariableDependence">
       <admst:return name="isDependent" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
   </admst:when>
   <admst:when test="[datatypename='mapply_unary']">
     <admst:apply-templates select="arg1" match="recursiveDetectVariableDependence">
       <admst:return name="isDependent" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
   </admst:when>
   <admst:when test="[datatypename='mapply_binary']">
     <admst:apply-templates select="arg1" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:apply-templates select="arg2" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:choose>
       <admst:when test="[$isDependent1='yes' or $isDependent2='yes']">
         <admst:return name="isDependent" value="yes"/>
       </admst:when>
       <admst:otherwise>
         <admst:return name="isDependent" value="no"/>
       </admst:otherwise>
     </admst:choose>
   </admst:when>
   <admst:when test="[datatypename='mapply_ternary']">
     <admst:apply-templates select="arg1" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:apply-templates select="arg2" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:apply-templates select="arg3" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent3" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:choose>
       <admst:when test="[$isDependent1='yes' or $isDependent2='yes' or $isDependent3='yes']">
         <admst:return name="isDependent" value="yes"/>
       </admst:when>
       <admst:otherwise>
         <admst:return name="isDependent" value="no"/>
       </admst:otherwise>
     </admst:choose>
   </admst:when>
   <admst:when test="[datatypename='function']">
     <admst:choose>
       <admst:when test="[name='\$simparam']">
         <admst:return name="isDependent" value="yes"/>
       </admst:when>
       <admst:otherwise>
         <admst:variable name="isFuncDependent" value="no"/>
         <admst:apply-templates select="arguments" match="recursiveDetectVariableDependence">
           <admst:if test="[returned('isDependent')/value = 'yes']">
             <admst:variable name="isFuncDependent" value="yes"/>
           </admst:if>
         </admst:apply-templates>
       </admst:otherwise>
     </admst:choose>
   </admst:when>
   <admst:otherwise>
     <admst:return name="isDependent" value="no"/>
   </admst:otherwise>
 </admst:choose>
 </admst:template>

<!--
 =================================================================-
 recursiveDetectParameterDependence
 Given any node, try to determine if the expression it represents has
 dependence on any parameters
 =================================================================-
 -->
<admst:template match="recursiveDetectParameterDependence">
  <admst:variable name="isDependent" value="no"/>
  <admst:choose>
    <admst:when test="[datatypename='number']">
      <!-- no changie da value.  -->
    </admst:when>
    <admst:when test="[(datatypename='variable' or datatypename='variableprototype') and type='real']">
      <admst:choose>
        <!-- This variable is a real parameter or explicitly depends on one or more real parameters -->
        <admst:when test="[exists(#Pdependent)]">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:when test="[input='yes' or exists(variable[input='yes'])]">
          <admst:variable name="isDependent" value="yes"/>
          <admst:value-to select="#Pdependent" value="yes"/>
        </admst:when>
        <!-- This variable does not explicitly depend on one or more parameters,
             but does depend on one or more non-parameter variables-->
        <admst:when test="[count(variable) > 0]">
          <admst:for-each select="variable">
            <admst:if test="[not (name=../name or (exists(#DONOTLOOP) and #DONOTLOOP='yes'))]">
              <!-- temporarily mark this variable as in process-->
              <admst:value-to select="#DONOTLOOP" value="yes"/>
              <admst:apply-templates select="." match="recursiveDetectParameterDependence">
                <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
                <admst:if test="[$isDependent1='yes']">
                  <admst:variable name="isDependent" value="yes"/>
                  <admst:value-to select="#Pdependent" value="yes"/>
                </admst:if>
              </admst:apply-templates>
              <!--clear the donotloop flag, seems to be no way to delete
                  a croixvar-->
              <admst:value-to select="#DONOTLOOP" value="no"/>
            </admst:if>
          </admst:for-each>
        </admst:when>
        <!-- This variable does not explicitly depend on one or more parameters,
             and does not depend other non-parameter variables-->
        <admst:otherwise>
          <!-- <admst:message format="recursiveDetectParameterDependence %(name) is independent of variables altogether\n"/>-->
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='expression']">
      <admst:apply-templates select="tree" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
        <admst:if test="[$isDependent1='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:if>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
        <admst:if test="[$isDependent1='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:if>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[$isDependent1='yes' or $isDependent2='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:otherwise>
          <!-- no changie da value -->
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg3" match="recursiveDetectParameterDependence">
        <admst:variable name="isDependent3" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[$isDependent1='yes' or $isDependent2='yes' or $isDependent3='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:otherwise>
          <!-- just leave isDependent where it is -->
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:choose>
        <admst:when test="[name='\$simparam']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="isFuncDependent" value="no"/>
          <admst:apply-templates select="arguments" match="recursiveDetectParameterDependence">
            <admst:if test="[returned('isDependent')/value = 'yes']">
              <admst:variable name="isFuncDependent" value="yes"/>
            </admst:if>
          </admst:apply-templates>
          <admst:if test="[$isFuncDependent='yes']">
            <admst:variable name="isDependent" value="yes"/>
          </admst:if>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='probe']">
      <!-- no changie da value -->
    </admst:when>
    <admst:when test="[(datatypename='variable' or datatypename='variableprototype') and type!='real']">
      <!-- ignore it: sensitivity is never run on integer vars -->
    </admst:when>
    <admst:otherwise>
      <admst:message format=" recursiveDetectParameterDependence on %(.) unimplemented datatype %(datatypename)\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="[$isDependent='yes']">
    <admst:value-to select="#Pdependent" value="yes"/>
  </admst:if>
  <admst:return name="isDependent" value="$isDependent"/>
</admst:template>

<!--
 =================================================================-
 recursiveDetectProbeDependence
 Given any node, try to determine if the expression it represents has
 dependence on any parameters
 =================================================================-
 -->
<admst:template match="recursiveDetectProbeDependence">
  <admst:variable name="isDependent" value="no"/>
  <admst:choose>
    <admst:when test="[datatypename='number']">
      <!-- no changie da value.  -->
    </admst:when>
    <admst:when test="[datatypename='variable' or datatypename='variableprototype']">
      <admst:choose>
        <!-- This variable explicitly depends on one or more parameters -->
        <admst:when test="[exists(probe)]">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <!-- This variable does not explicitly depend on one or more parameters,
             but does depend on one or more non-parameter variables-->
        <admst:when test="[count(variable[name!=./name]) > 0]">
          <admst:apply-templates select="variable" match="recursiveDetectProbeDependence">
            <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
            <admst:if test="[$isDependent1='yes']">
              <admst:variable name="isDependent" value="yes"/>
            </admst:if>
          </admst:apply-templates>
        </admst:when>
        <!-- This variable does not explicitly depend on one or more parameters,
             and does not depend other non-parameter variables-->
        <admst:otherwise>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='expression']">
      <admst:apply-templates select="tree" match="recursiveDetectProbeDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
        <admst:if test="[$isDependent1='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:if>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="recursiveDetectProbeDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
        <admst:if test="[$isDependent1='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:if>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1" match="recursiveDetectProbeDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="recursiveDetectProbeDependence">
        <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[$isDependent1='yes' or $isDependent2='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:otherwise>
          <!-- no changie da value -->
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1" match="recursiveDetectProbeDependence">
        <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="recursiveDetectProbeDependence">
        <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg3" match="recursiveDetectProbeDependence">
        <admst:variable name="isDependent3" value="%(returned('isDependent')/value)"/>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[$isDependent1='yes' or $isDependent2='yes' or $isDependent3='yes']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:otherwise>
          <!-- just leave isDependent where it is -->
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:choose>
        <admst:when test="[name='\$simparam']">
          <admst:variable name="isDependent" value="yes"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="isFuncDependent" value="no"/>
          <admst:apply-templates select="arguments" match="recursiveDetectProbeDependence">
            <admst:if test="[returned('isDependent')/value = 'yes']">
              <admst:variable name="isFuncDependent" value="yes"/>
            </admst:if>
          </admst:apply-templates>
          <admst:if test="[$isFuncDependent='yes']">
            <admst:variable name="isDependent" value="yes"/>
          </admst:if>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:message format=" recursiveDetectProbeDependence on %(.) unimplemented datatype\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:return name="isDependent" value="$isDependent"/>
</admst:template>

 <!--
 =================================================================-
 collectLimiters
 Given a module, create an "arobavar" (@limiters) containing all the
 assignments in which the verilog limiter function is called.
 Also, create another arobavar (@limitedProbes) containing just
 the probes that are limited by those assignments.
 This template is called early in processing, and the arrays it
 produces will be used to produce the various bits of code needed
 to implement voltage limiting in the device.

  Example:  <admst:apply-templates select="/module" match="collectLimiters"/>

  will result in there being a /module/@limiters and /module/@limitedProbes
 =================================================================-
-->

<admst:template match="collectLimiters">
  <admst:variable name="thisModule" select="%(.)"/>
  <admst:for-each select="assignment[rhs/function/name='\$limit']">
    <admst:push into="../@limiters" select="." onduplicate="ignore"/>
  </admst:for-each>
  <admst:for-each select="@limiters">
    <admst:for-each select="rhs/probe">
      <admst:value-to select="#limited" string="yes"/>
      <admst:if test="[../function/[name='\$limit']/arguments[2]/datatypename='string']">
        <admst:if test="[../function/[name='\$limit']/arguments[2]/value='typedpnjlim' or ../function/[name='\$limit']/arguments[2]/value='typedpnjlim_new' or ../function/[name='\$limit']/arguments[2]/value='typeddummy' or ../function/[name='\$limit']/arguments[2]/value='typedfetlim' or (../function/[name='\$limit']/arguments[3]/datatypename='string' and ../function/[name='\$limit']/arguments[3]/value='typed')]">
          <admst:value-to select="#typed" string="yes"/>
        </admst:if>
      </admst:if>
      <admst:push into="$thisModule/@limitedProbes" select="." onduplicate="ignore"/>
    </admst:for-each>
  </admst:for-each>
</admst:template>

<!--
 =================================================================-
 collectCollapsibles
 This template is intended to be called very early in verilog processing.
 It runs through all contributions and tries to identify those that
 allow some node to be collapsed into another (i.e. contributions of the
 form "V(a,b) <+ 0;"
 If it locates such a collapsible, it adds a "#collapsible='yes'" variable
 to the node, and a "@collapsesTo" variable containing the node to which
 this one could collapse.
 In considering which node to collapse of a,b, if there's only one internal
 in the pair, that's the collapsible one.  If both are internal, it'll
 collapse the negative into the positive.
 =================================================================-
 -->
<admst:template match="collectCollapsibles">
  <admst:variable name="thisModule" select="%(.)"/>
  <admst:if test="[not exists(#calledCollectCollapsibles)]">
    <admst:for-each select="$thisModule/contribution[lhs/discipline/potential=lhs/nature]">
      <admst:if test="[(rhs/datatypename='expression' and rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0')) or (rhs/datatypename='number' and (rhs/value='0' or rhs/value='0.0'))]">
        <admst:choose>
          <admst:when test="lhs/branch[grounded='no']">
            <admst:choose>
              <admst:when test="lhs/branch/nnode[location='internal']">
                <!-- <admst:warning format="collectCollapsibles found internal nnode %(lhs/branch/nnode/name) it wants to collapse into %(lhs/branch/pnode/name)\n"/> -->
                <!-- nnode is internal, collapse it into pnode -->
                <admst:if test="[exists(lhs/branch/nnode/#collapsible) and lhs/branch/nnode/#collapsible='yes']">
                  <!-- nnode is already collapsible to something, so don't just
                       blindly collapse it to pnode... check that pnode is
                       not collapsible, and collapse p into n if not -->
                  <!-- <admst:warning format="    %(lhs/branch/nnode/name) is already collapsible...\n"/> -->
                  <admst:choose>
                    <admst:when test="[not(exists(lhs/branch/pnode/#collapsible))]">
                      <!-- <admst:warning format="    but %(lhs/branch/pnode/name) is not collapsible...\n"/> -->
                      <admst:choose>
                        <admst:when test="[lhs/branch/pnode/name=lhs/branch/nnode/@collapsesTo/name]">
                          <!-- <admst:warning format="But that is OK, because we were already going to do that collapsing!\n"/> -->
                        </admst:when>
                        <admst:when test="lhs/branch/pnode[location='external']">
                          <!-- <admst:warning format="     unfortunately, that is external... rearranging\n"/> -->
                          <!-- <admst:warning format="     we will make %(lhs/branch/nnode/@collapsesTo/name) collapse to %(lhs/branch/nnode/name) instead, and make %(lhs/branch/nnode/name) collapse to %(lhs/branch/pnode/name) instead\n"/> -->
                          <admst:variable name="saveCollapse" select="%(lhs/branch/nnode/@collapsesTo)"/>
                          <admst:if test="[exists($saveCollapse/#collapsible)]">
                            <admst:error format="fatal error --- tried to rearrange collapsing of %(lhs/branch/nnode/name) and %($saveCollapse/name) but the latter is already collapsible.\n"/>
                          </admst:if>
                          <admst:value-to select="$saveCollapse/#collapsible" string="yes"/>
                          <admst:push into="$saveCollapse/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
                          <admst:reset select="lhs/branch/nnode/@collapsesTo"/>
                          <admst:push into="lhs/branch/nnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/pnode"/>
                        </admst:when>
                        <admst:otherwise>
                          <admst:value-to select="lhs/branch/pnode/#collapsible" string="yes"/>
                          <admst:push into="lhs/branch/pnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
                        </admst:otherwise>
                      </admst:choose>
                    </admst:when>
                    <admst:otherwise>
                      <!-- this is only an error if trying to collapse nnode
                           into something OTHER than what it already collapses
                           to.  -->
                      <admst:if test="[(lhs/branch/pnode/name != lhs/branch/nnode/@collapsesTo/name) and (lhs/branch/nnode/name != lhs/branch/pnode/@collapsesTo/name)]">
                        <admst:error format="Not yet supported: collapsing a node multiply... both %(lhs/branch/nnode/name) and %(lhs/branch/pnode/name) are already collapsible.  %(lhs/branch/nnode/name) collapses already into %(lhs/branch/nnode/@collapsesTo) and %(lhs/branch/pnode/name) collapses already into %(lhs/branch/pnode/@collapsesTo)\n"/>
                      </admst:if>
                    </admst:otherwise>
                  </admst:choose>
                </admst:if>
                <admst:if test="[not(exists(lhs/branch/nnode/#collapsible))]">
                  <!-- nnode is not already collapsible, collapse it into p -->
                  <admst:value-to select="lhs/branch/nnode/#collapsible" string="yes"/>
                  <admst:push into="lhs/branch/nnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/pnode"/>
                </admst:if>
              </admst:when>
              <admst:when test="lhs/branch/pnode[location='internal']">
                <!-- we only get here if nnode was external -->
                <admst:value-to select="lhs/branch/pnode/#collapsible" string="yes"/>
                <admst:push into="lhs/branch/pnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="lhs/branch/nnode/[grounded='yes']">
                <admst:value-to select="lhs/branch/pnode/#collapsible" string="yes"/>
                <admst:push into="lhs/branch/pnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
              </admst:when>
              <admst:when test="lhs/branch/pnode/[grounded='yes']">
                <admst:value-to select="lhs/branch/nnode/#collapsible" string="yes"/>
                <admst:push into="lhs/branch/nnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/pnode"/>
              </admst:when>
            </admst:choose>

          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:for-each>
    <admst:value-to select="$thisModule/#calledCollectCollapsibles" string="yes"/>
  </admst:if>
</admst:template>

<!--
 =================================================================-
 declareCollapsibleBools
 For each node that may be collapsed, generate a declaration of a bool
 that will be used by Xyce to tell whether to collapse it or not.
 Pass the module in the select field of the apply-templates call.
 =================================================================-
 -->
<admst:template match="declareCollapsibleBools">
  <admst:if test="[count(node[#collapsible='yes'])>0]">
    <admst:text format="     // bools for collapsing nodes\n"/>
    <admst:for-each select="node[#collapsible='yes']">
      <admst:text format="     bool collapseNode_%(name);\n"/>
    </admst:for-each>
  </admst:if>
</admst:template>

  <!--
      recursiveFindContrib
      This template is passed any item from the analog/code block,
      and recurses downward until it finds a contribution of the form
      V(branch) <+ 0;   (or 0.0)
      When it finds one, it recurses upwards through the ADMS data tree
      using the upwardRecurseCheckDepend template.
  -->

  <admst:template match="recursiveFindContrib">
    <admst:choose>
      <admst:when test="adms[datatypename='block']">
        <admst:apply-templates select="item" match="recursiveFindContrib"/>
      </admst:when>
      <admst:when test="adms[datatypename='conditional']">
        <admst:apply-templates select="then" match="recursiveFindContrib"/>
        <admst:apply-templates select="else" match="recursiveFindContrib"/>
      </admst:when>
      <admst:when test="adms[datatypename='case']">
        <admst:for-each select="caseitem">
          <admst:apply-templates select="code" match="recursiveFindContrib"/>
        </admst:for-each>
      </admst:when>
      <admst:when test="adms[datatypename='contribution']">
        <admst:if test="[(lhs/discipline/potential=lhs/nature) and ((rhs/datatypename='expression' and rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0')) or (rhs/datatypename='number' and (rhs/value='0' or rhs/value='0.0')))]">
          <admst:apply-templates select="." match="upwardRecurseCheckDepend"/>
        </admst:if>
      </admst:when>
    </admst:choose>
  </admst:template>

  <!--
      upwardRecurseCheckDepend
      Given any ADMS data tree item, recurse UPWARD through the ADMS data
      tree.  Check that all conditionals depend only on variables of
      global_instance or global_model scope, or are input parameters.

      Flag a fatal error if any local variables are used in these
      conditional expressions.  We just flag the error, we don't
      abort, so the entire processing of the module can proceed and
      report all errors.  The caller must check the "$collapseFailure"
      variable and abort if it's "yes".

      The starting point should be a contribution that collapses nodes, e.g.
      V(branch) <+ 0;
      -->
  <admst:template match="upwardRecurseCheckDepend">
    <admst:choose>
      <admst:when test="adms[datatypename='expression']">
        <admst:for-each select="variable">
          <admst:if test="[not (input='yes' or (scope='global_instance' or scope='global_model'))]">
            <admst:warning format="Collapse error:  Node collapse conditional depends on variable %(name), which is not an input parameter and which has scope of '%(scope)'.\n\n  Only variables of global_instance or global_model scope may be used in collapse conditionals in this version of Xyce/ADMS.\n\n  To clear this error, move bias-independent intialization of %(name) into an '@(initial_instance)' or '@(initial_model) block.\n"/>
            <admst:variable name="collapseFailure" string="yes"/>
          </admst:if>
          <admst:if test="[OPdependent='yes']">
            <admst:warning format="  Collapse error:  Node collapse conditional depends on variable %(name) that is bias-dependent.  Collapse conditionals must be bias-independent.\n"/>
            <admst:variable name="collapseFailure" string="yes"/>
          </admst:if>
        </admst:for-each>
      </admst:when>
      <admst:when test="adms[datatypename='conditional']">
        <admst:apply-templates select="if" match="upwardRecurseCheckDepend"/>
      </admst:when>
      <admst:when test="adms[datatypename='case']">
        <admst:apply-templates select="case" match="upwardRecurseCheckDepend"/>
      </admst:when>
    </admst:choose>
    <admst:if test="[not(../adms/datatypename = 'analog' or ./adms/datatypename='expression')]">
      <admst:apply-templates select=".." match="upwardRecurseCheckDepend"/>
    </admst:if>
  </admst:template>


  <!--
      evaluateCollapse
      Emit code for evaluating when to collapse nodes.
      Only assignments that assign to variables that collapse depends on
      are emitted.
      Control structures that CONTAIN assignments that are emitted will also
      be generated, e.g.

      if (foo)
        bar=baz;

      will generate code if bar is a collapse-determining variable.

      TODO:  If we find we need to generate FOR or WHILE loops, then we
      should give up and report an error.  Handling these constructs correctly
      is too difficult, and no rational model should ever have collapse
      determination that requires it.  No currently known models do.

  -->
  <admst:template match="evaluateCollapse">
    <admst:choose>

      <!--IF/ELSE-->
      <admst:when test="[datatypename='conditional']">
        <admst:choose>
          <admst:when test="if[nilled(variable[OPdependent='yes'])]">
            <admst:choose>
              <admst:when test="if/math[dependency='constant']">
                <admst:variable name="thenOutputSomething" string="no"/>
                <admst:variable name="thenOutput" string=""/>
                <admst:variable name="elseOutputSomething" string="no"/>
                <admst:variable name="elseOutput" string=""/>
                <admst:apply-templates select="then" match="evaluateCollapse">
                  <admst:value-of select="returned('outputSomething')/value"/>
                  <admst:variable name="thenOutputSomething" select="%s"/>
                  <admst:value-of select="returned('output')/value"/>
                  <admst:variable name="thenOutput" select="%s"/>
                </admst:apply-templates>
                <admst:if test="[exists(else)]">
                  <admst:apply-templates select="else" match="evaluateCollapse">
                    <admst:value-of select="returned('outputSomething')/value"/>
                    <admst:variable name="elseOutputSomething" select="%s"/>
                    <admst:value-of select="returned('output')/value"/>
                    <admst:variable name="elseOutput" select="%s"/>
                  </admst:apply-templates>
                </admst:if>

                <admst:if test="[$thenOutputSomething='yes']">
                  <admst:variable name="output" string="if (%(processTerm(if)/[name='returnedExpression']/value))"/>
                  <admst:variable name="output" string="$output\n{\n$thenOutput\n}\n"/>
                  <admst:if test="[$elseOutputSomething='yes']">
                    <admst:variable name="output" string="$output\nelse\n{\n$elseOutput\n}\n"/>
                  </admst:if>
                  <admst:variable name="outputSomething" string="yes"/>
                </admst:if>
                <admst:if test="[$thenOutputSomething='no' and $elseOutputSomething='yes']">
                  <admst:variable name="output" string="if (!(%(processTerm(if)/[name='returnedExpression']/value)))"/>
                  <admst:variable name="output" string="$output\n{\n$elseOutput\n}\n"/>
                </admst:if>

                <admst:choose>
                  <admst:when test="[$thenOutputSomething='yes' or $elseOutputSomething='yes']">
                    <admst:return name="outputSomething" string="yes"/>
                    <admst:return name="output" string="$output"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="outputSomething" string="no"/>
                    <admst:return name="output" string=""/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="thenOutputSomething" string="no"/>
                <admst:variable name="thenOutput" string=""/>
                <admst:variable name="elseOutputSomething" string="no"/>
                <admst:variable name="elseOutput" string=""/>
                <admst:apply-templates select="then" match="evaluateCollapse">
                  <admst:value-of select="returned('outputSomething')/value"/>
                  <admst:variable name="thenOutputSomething" select="%s"/>
                  <admst:value-of select="returned('output')/value"/>
                  <admst:variable name="blockOutput" select="%s"/>
                  <admst:if test="[$thenOutputSomething = 'yes']">
                    <admst:variable name="thenOutput" string="%($blockOutput)\n"/>
                  </admst:if>
                </admst:apply-templates>
                <admst:apply-templates select="else" match="evaluateCollapse">
                  <admst:value-of select="returned('outputSomething')/value"/>
                  <admst:variable name="elseOutputSomething" select="%s"/>
                  <admst:value-of select="returned('output')/value"/>
                  <admst:variable name="blockOutput" select="%s"/>
                  <admst:if test="[$elseOutputSomething = 'yes']">
                    <admst:variable name="outputSomething" string="yes"/>
                    <admst:variable name="elseOutput" string="%($blockOutput)"/>
                  </admst:if>
                </admst:apply-templates>
                <admst:variable name="output" string="%($thenOutput)%($elseOutput)"/>
                <admst:choose>
                  <admst:when test="[$thenOutputSomething='yes' or $elseOutputSomething='yes']">
                    <admst:return name="outputSomething" string="yes"/>
                    <admst:return name="output" string="$output"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="outputSomething" string="no"/>
                    <admst:return name="output" string=""/>
                  </admst:otherwise>
                </admst:choose>

              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:return name="outputSomething" string="no"/>
            <admst:return name="output" string=""/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>

      <!-- CASE -->
      <admst:when test="[datatypename='case']">
        <admst:choose>
          <admst:when test="case[nilled(variable[OPdependent='yes'])]">
            <admst:variable name="caseOutputSomething" string="no"/>
            <admst:variable name="fullCaseOutput" string=""/>
            <admst:variable name="haveDefault" string="no"/>
            <admst:if test="[count(caseitem[defaultcase='yes'])>0]">
              <admst:variable name="haveDefault" string="yes"/>
            </admst:if>
            <admst:choose>
              <admst:when test="case/math[dependency='constant']">
                <admst:variable name="caseConditionExpr" string="%(processTerm(case)/[name='returnedExpression']/value)"/>
                <admst:for-each select="caseitem[defaultcase='no']">
                  <admst:apply-templates select="code" match="evaluateCollapse">
                    <admst:value-of select="returned('outputSomething')/value"/>
                    <admst:variable name="caseItemOutputSomething" select="%s"/>
                    <admst:value-of select="returned('output')/value"/>
                    <admst:variable name="caseItemOutput" select="%s"/>
                    <admst:if test="[$caseItemOutputSomething='yes']">
                      <admst:variable name="caseOutputSomething" string="yes"/>
                    </admst:if>
                    <!-- now assemble the conditional for output -->
                    <admst:variable name="oredCondition" string=""/>
                    <admst:for-each select="../condition">
                      <admst:apply-templates select="." match="%(datatypename)">
                        <admst:if test="[$oredCondition != '']">
                          <admst:variable name="oredCondition" string="$oredCondition || "/>
                        </admst:if>
                        <admst:variable name="oredCondition" string="$oredCondition ($caseConditionExpr == %(returned('returnedExpression')/value))"/>
                      </admst:apply-templates>
                    </admst:for-each>  <!-- condition -->
                  </admst:apply-templates>
                  <!-- add the conditional to the output -->
                  <admst:variable name="fullCaseOutput" string="$fullCaseOutput if ( $oredCondition )\n"/>
                  <admst:if test="[$caseItemOutputSomething = 'yes']">
                    <admst:variable name="fullCaseOutput" string="$fullCaseOutput{\n$caseItemOutput\n}\nelse\n"/>
                  </admst:if>
                  <admst:if test="[$caseItemOutputSomething = 'no']">
                    <admst:variable name="fullCaseOutput" string="$fullCaseOutput\n{\n // nothing to see here \n}\nelse\n"/>
                  </admst:if>
                </admst:for-each> <!-- non-default caseitem-->
                <!-- now handle a default if we have one
                     because we've been emitting all those "else" lines,
                     we will emit an empty block just to keep syntax right -->
                <admst:if test="[$haveDefault='no']">
                  <admst:variable name="fullCaseOutput" string="$fullCaseOutput{\n // there is no default \n}\n"/>
                </admst:if>
                <admst:if test="[$haveDefault='yes']">
                  <admst:for-each select="caseitem[defaultcase='yes']">
                    <admst:apply-templates select="code" match="evaluateCollapse">
                      <admst:value-of select="returned('outputSomething')/value"/>
                      <admst:variable name="caseItemOutputSomething" select="%s"/>
                      <admst:value-of select="returned('output')/value"/>
                      <admst:variable name="caseItemOutput" select="%s"/>
                      <admst:if test="[$caseItemOutputSomething='yes']">
                        <admst:variable name="caseOutputSomething" string="yes"/>
                    <admst:variable name="fullCaseOutput" string="$fullCaseOutput{\n$caseItemOutput\n}\n"/>
                      </admst:if>
                      <admst:if test="[$caseItemOutputSomething='no']">
                        <admst:variable name="fullCaseOutput" string="$fullCaseOutput{\n//nothing to see here\n}\n"/>
                      </admst:if>
                    </admst:apply-templates>
                  </admst:for-each> <!-- really just one default -->
                </admst:if>
                <admst:return name="outputSomething" string="$caseOutputSomething"/>
                <admst:return name="output" string="$fullCaseOutput"/>
              </admst:when>
              <admst:otherwise>
                <admst:error format="evaluateCollapse: case not constant, we can't handle that yet.\n"/>
                <admst:return name="outputSomething" string="no"/>
                <admst:return name="output" string=""/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
             <!-- do nothing -->
            <admst:return name="outputSomething" string="no"/>
            <admst:return name="output" string=""/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>

      <!--CONTRIBUTION-->
      <admst:when test="[datatypename='contribution']">
        <admst:choose>
          <admst:when test="lhs[discipline/potential=nature]">
            <admst:choose>
              <admst:when test="[exists(lhs/branch/nnode/#collapsible) and lhs/branch/nnode/#collapsible='yes' and lhs/branch/nnode/@collapsesTo=lhs/branch/pnode]">
                <admst:return name="output" string="collapseNode_%(lhs/branch/nnode/name) = true;\n"/>
                <admst:return name="outputSomething" string="yes"/>
              </admst:when>
              <admst:when test="[exists(lhs/branch/pnode/#collapsible) and lhs/branch/pnode/#collapsible='yes' and lhs/branch/pnode/@collapsesTo=lhs/branch/nnode]">
                <admst:return name="output" string="collapseNode_%(lhs/branch/pnode/name) = true;\n"/>
                <admst:return name="outputSomething" string="yes"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="output" string=""/>
                <admst:return name="outputSomething" string="no"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:return name="output" string=""/>
            <admst:return name="outputSomething" string="no"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>

      <!--BLOCK-->
      <admst:when test="[datatypename='block']">
        <admst:value-to select="./#tempOutput" value=""/>
        <admst:value-to select="./#tempOutputSomething" value="no"/>
        <admst:variable name="outputSomething" value="no"/>
        <admst:if test="[name != '']">
          <admst:value-to select="./#tempOutput" value="// begin block named %(name)\n"/>
        </admst:if>
        <admst:for-each select="variable[#collapseDepends='yes']">
          <admst:value-to select="./#tempOutputSomething" value="yes"/>
          <admst:variable name="outputSomething" value="yes"/>
          <admst:if test="[type='integer']">
            <admst:value-to select="../#tempOutput" value="%(../#tempOutput)int %(name);\n"/>
          </admst:if>
          <admst:if test="[type='real']">
            <admst:value-to select="../#tempOutput" value="%(../#tempOutput)double %(name)\n"/>
          </admst:if>
          <admst:if test="[type='string']">
            <admst:value-to select="../#tempOutput" value="%(../#tempOutput)char * %(name)\n"/>
          </admst:if>
        </admst:for-each>

        <admst:apply-templates select="item" match="evaluateCollapse">
          <admst:value-of select="returned('outputSomething')/value"/>
          <admst:variable name="blockOutputSomething" select="%s"/>
          <admst:value-of select="returned('output')/value"/>
          <admst:variable name="blockOutput" select="%s"/>
          <admst:if test="[$blockOutputSomething = 'yes']">
            <admst:variable name="outputSomething" string="yes"/>
            <admst:value-to select="../#tempOutputSomething" value="yes"/>
            <admst:variable name="tempOutput" select="%(../#tempOutput)\n$blockOutput"/>
            <admst:value-to select="../#tempOutput" value="$tempOutput"/>
          </admst:if>
        </admst:apply-templates>
        <admst:variable name="output" select="%(./#tempOutput)"/>
        <admst:if test="[name != '']">
          <admst:variable name="output" select="%($output)\n// end block  named %(name)\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[./#tempOutputSomething='yes']">
            <admst:return name="output" string="$output"/>
            <admst:return name="outputSomething" string="yes"/>
          </admst:when>
          <admst:otherwise>
            <admst:return name="output" string=""/>
            <admst:return name="outputSomething" string="no"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>


      <!--other stuff to ignore-->
      <admst:when test="[datatypename='expression' or datatypename='probe' or datatypename='variable' or datatypename='mapply_unary' or datatypename='mapply_binary' or datatypename='mapply_ternary' or datatypename='function' or datatypename='number' or datatypename='string' or datatypename='nilled' or datatypename='blockvariable' or datatypename='callfunction' or datatypename='case' or datatypename='whileloop' or datatypename='forloop' or datatypename='assignment']">
        <admst:return name="output" string=""/>
        <admst:return name="outputSomething" string="no"/>
      </admst:when>

      <admst:otherwise>
        <admst:fatal format="%(datatypename): adms element not implemented\n"/>
      </admst:otherwise>
    </admst:choose>

    <!-- we have to clear this now, and it has to be after the return.
         If we clear it before the return, somehow $output gets cleared.  Is
         that because it's still tied to the memory location of #tempoutput?
         And if we do NOT clear it, we consume all available memory and puke
         on complex files. -->
    <admst:value-to select="./#tempOutput" value=""/>
  </admst:template>

<!--
   =================================================================-
   collectExtraUnknowns
   Another "execute early in the processing" deal.
   Any use of "flow probes" requires an extra unknown (the flow through
   the branch).
   Any use of "potential sources" *also* requires an extra unknown (also
   the flow through the branch).
   These two cases also, naturally, require an additional equation.  There
   are multiple possibilities:

    A)  Flow probe used only in a flow source, without any associated
        contribution:
        I(b2) &lt;+ I(b1);
        In this case, the extra unknown is I(b1), and the extra equation is
          V(b1) = 0.

    B)  Flow probe used in a flow source, with an associated contribution:
        I(b1) &lt;+ expression;
        I(b2) &lt;+ A*I(b1);
        In this case, the extra unknown is I(b1), but the extra equation is:
          sum(contributions into I(b1)) -I(b1) = 0

    C)  Potential source
        V(B1) &lt;+ expression_not_referencing_the_branch_B1;
        Extra unknown is still I(B1), extra equation is:
          sum (all contributions into V(B1)) - V(B1) = 0

    D) Potential source referencing a flow probe:
        V(b1) &lt;+ expression;
        V(b2) &lt;+ A*I(B1)
        Extra unknown is I(B1), extra equation same as C

   Of course, each of these impacts the loads for the KCLs of the endpoints
   of B1 and B2.

      A) add/subtract I(B1) to endpoint nodes of B1
      B) add/subtract I(B1) to endpoint nodes of B1
      C) add/subtract I(B1) to endpoints of B1
      D) add/subtract I(B1) to endpoints of B1, use unknown I(B1) in
         equations for endpoints of B2.

   There are other cases, too, but these are already handled elsewhere.

   The purpose of this template is to figure out which new unknowns to
   allocate for, which is pretty easy (look for flow probes in the module's
   list of probes, and look for potential sources that aren't already flagged
   as collapsible (zero RHS) in the module's list of sources: each one
   means there has to be an associated current branch).

   Determining what type of *equation* to do really depends on the contribution
   involved.
   -->
<admst:template match="collectExtraUnknowns">
  <admst:variable name="thisModule" select="%(.)"/>
  <admst:reset select="$thisModule/@extraUnknowns"/>

  <!-- First find the extra unknowns due to flow probes -->
  <admst:for-each select="/module/probe[nature=discipline/flow]">
    <admst:push into="$thisModule/@extraUnknowns" select="branch" onduplicate="ignore"/>
    <admst:value-to select="#branchvar" string="yes" />
  </admst:for-each>

  <!-- Now find the extra unknowns due to potential sources -->
  <admst:for-each select="$thisModule/source[not(exists(branch/nnode/#collapsible)) and not(exists(branch/pnode/#collapsible)) and nature=discipline/potential]">
    <admst:push into="$thisModule/@extraUnknowns" select="branch" onduplicate="ignore"/>
  </admst:for-each>

  <!-- we now know the extra unknowns, which are all branches.  Unfortunately,
       ADMS does not store any information about this stuff in its "jacobian"
       structure, which makes life difficult for us.  So let us create our
       own data.  -->
  <!-- we'll make three arrays to help us figure out jacobian stuff

       we need a list of nodes
       that depend on branch variables.  We'll push the branch into the
       node. We handle this by pushing the list of branch dependencies
       into the actual node structure.

       We need  a list of branches that depend on nodal vars.
       This will let us create the jacobian row for the branch and fill it
       with nodal dependencies.  These will simply be put in an array
       inside the @extraUnknowns array called @nodeDeps.

       We need a list of branches that depend on branch vars.
       This will let us augment the branch equation rows.  This, too,
       will be stored in the @branchDeps array under the @extraUnknowns.
       -->
    <admst:for-each select="$thisModule/@extraUnknowns">
    <admst:variable name="thisBranch" select="%(.)"/>

      <admst:push into="pnode/@branchDeps" select="." onduplicate="ignore"/>
      <admst:if test="[nnode/grounded = 'no']">
        <admst:push into="nnode/@branchDeps" select="." onduplicate="ignore"/>
      </admst:if>

      <admst:apply-templates match="collectBranchDepends" select="."/>
      <admst:for-each select="/module/@countNodes">
        <admst:push into="$thisBranch/@nodeDeps" select="." onduplicate="ignore"/>
      </admst:for-each>
      <admst:for-each select="/module/@countBranches">
        <admst:push into="$thisBranch/@branchDeps" select="." onduplicate="ignore"/>
      </admst:for-each>
    </admst:for-each>

    <!-- Finally, we have an issue:  if a voltage source is uses, but
         the corresponding current probe is never used (such is done if
         one has a pure voltage source), then our process so far will never
         allocate a place for the current branch probe that we need to use in
         updateIntermediateVars.  So here, we'll go through our list of
         extra branch equations and make a list of branches for which there
         is no probe in the tree.  This will be used later to allocate what's
         missing. -->
    <admst:reset select="$thisModule/@extraProbeBranches"/>
    <admst:for-each select="$thisModule/@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(nnode/name)"/>
      <admst:if test="[not(exists($thisModule/probe[nature=discipline/flow and branch/pnode/name=$thePnodeName and branch/nnode/name=$theNnodeName]))]">
        <admst:push into="$thisModule/@extraProbeBranches" select="." onduplicate="ignore"/>
      </admst:if>
    </admst:for-each>

<!--   Debugging output commented out

  <admst:for-each select="$thisModule/@extraUnknowns">
    // branch %(.) depends on nodes %(@nodeDeps)
    // branch %(.) depends on branches %(@branchDeps)

  </admst:for-each>

  <admst:for-each select="$thisModule/node[grounded='no']">
    <admst:if test="[not(nilled(@branchDeps))]">
      // Node %(.) depends on branches %(@branchDeps)

    </admst:if>
  </admst:for-each>
-->
</admst:template>


  <!--
   =================================================================-
   finishUpBranchEquations

   Branch equations are of the form:
     (sum of contributions into source) - (value of source) = 0

   Our contribution template does the sum part, but we now need to do
   the last bit.

    . must be a module
   =================================================================-
   -->
  <admst:template match="finishUpBranchEquations">

    <admst:variable name="thisModule" select="%(.)"/>
    <admst:for-each select="./contribution[lhs/nature=lhs/discipline/potential and not(rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0'))]">
      <!-- do nothing if a noise term -->
      <admst:if test="[whitenoise='no' and flickernoise='no']">

        <!-- The extra terms into the voltage nodes are only done once,
             and only into the static contributions. -->
        <admst:variable name="pnode" select="%(lhs/branch/pnode)"/>
        <admst:variable name="pnodeConstant" select="%(xyceNodeConstantName($pnode)/[name='nodeConstant']/value)"/>
        <admst:variable name="nnode" select="%(lhs/branch/nnode)"/>
        <admst:if test="[rhs/static='yes' or (rhs/dynamic='yes' and not(exists($thisModule/contribution[lhs/nature=lhs/discipline/potential and lhs/branch/pnode=$pnode and lhs/branch/nnode=$nnode and rhs/static='yes'])))]">
          // Additional term resulting from contributions into %(lhs)

          <admst:text format="staticContributions[$pnodeConstant] += probeVars[%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)];\n"/>
          <admst:if test="$nnode[grounded='no']">
            <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
            <admst:text format="staticContributions[$nnodeConstant] -= probeVars[%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)];\n"/>
          </admst:if>
        </admst:if>
      </admst:if>
    </admst:for-each>

    <admst:for-each select="./@extraUnknowns">
      <!-- There is one special case:  a branch where the
           flow probe is used AND there is a flow source for it.
            In this case the branch equation is
              (sum of contributions into I(branch)) - I(branch) =0

            In all other cases, the branch equation will always be:
              (sum of contributions into V(branch)) - V(branch) = 0
       -->
       <admst:text format="  // Final term for branch equation %(xyceBranchConstantName(.)/[name='branchConstant']/value) \n"/>
  <admst:variable name="thePnodeName" select="%(pnode/name)"/>
  <admst:variable name="theNnodeName" select="%(nnode/name)"/>
       <admst:choose>
         <admst:when test="[exists(/module/contribution[lhs/branch/pnode/name='$thePnodeName' and lhs/branch/nnode/name='$theNnodeName' and lhs/nature=lhs/discipline/flow])]">
           <admst:text format="  staticContributions[%(xyceBranchConstantName(.)/[name='branchConstant']/value)] -= probeVars[%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>
         </admst:when>
         <admst:otherwise>
           <!-- ICK.  In this case, we don't usually HAVE a probe variable,
                and so we must calculate the drop V(branch) directly.
                We can't rely on Sacado to do derivatives w.r.t. this,
                and will have to have a manual +/- dependence in the
                branch's static jacobian. -->
           <admst:text format="  staticContributions[%(xyceBranchConstantName(.)/[name='branchConstant']/value)] -= (*solVectorPtr)[%(xyceNodeLIDVariable(./pnode))]"/>
           <admst:if test="[nnode/grounded='no']">
             <admst:text format="-(*solVectorPtr)[%(xyceNodeLIDVariable(./nnode))]"/>
           </admst:if>
         <admst:text format=";\n"/>
         </admst:otherwise>
       </admst:choose>

    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   verilog2CXXtype
     given an admst data tree node, return the C++ datatype
     corresponding to its type
    The node passed in is usually a variable
   =================================================================-
  -->
  <admst:template match="verilog2CXXtype">
    <admst:choose>
      <admst:when test="[type='integer']">
        <admst:text format="int"/>
      </admst:when>
      <admst:when test="[type='real']">
        <admst:text format="double"/>
      </admst:when>
      <admst:when test="[type='string']">
        <admst:text format="string"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="should not be reached\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   textUnit2XyceUnit
   given an admst data tree element with a "units" attribute,
   output the corresponding "U_" string
   =================================================================-
  -->
  <admst:template match="textUnit2XyceUnit">
    <admst:choose>
      <!-- Simple units -->
      <admst:when test="[attribute/[name='units']/value = 'm']">
        <admst:text format="U_METER"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'm^2']">
        <admst:text format="U_METER2"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'm^-3']">
        <admst:text format="U_METERM3"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'F']">
        <admst:text format="U_FARAD"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Ohm']">
        <admst:text format="U_OHM"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'V']">
        <admst:text format="U_VOLT"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = '/V' or attribute/[name='units']/value = 'V^-1']">
        <admst:text format="U_VOLTM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'V^-0.5']">
        <admst:text format="U_VOLTMH"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'A']">
        <admst:text format="U_AMP"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'S' or attribute/[name='units']/value = '1/Ohm']">
        <admst:text format="U_OHMM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 's']">
        <admst:text format="U_SECOND"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'K']">
        <admst:text format="U_DEGK"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'K^-1' or attribute/[name='units']/value = '1/K']">
        <admst:text format="U_DEGKM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'degC']">
        <admst:text format="U_DEGC"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = '/C' or attribute/[name='units']/value = '1/C' or attribute/[name='units']/value = 'degC^-1']">
        <admst:text format="U_DEGCM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'C']">
        <admst:text format="U_COULOMB"/>
      </admst:when>
      <!-- Complex units -->
      <admst:when test="[attribute/[name='units']/value = 'V/K']">
        <admst:text format="U_VKM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'm^2/V/s']">
        <admst:text format="U_M2VM1SM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'm/V']">
        <admst:text format="U_MVM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Vm']">
        <admst:text format="U_VM"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Vm^-1']">
        <admst:text format="U_VMM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'A/V^3' or attribute/[name='units']/value = 'AV^-3' ]">
        <admst:text format="U_AMPVM3"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am/V^3' or attribute/[name='units']/value = 'AV^-3m' ]">
        <admst:text format="U_AMPVM3M"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am^-1']">
        <admst:text format="U_AMPMM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am^-2']">
        <admst:text format="U_AMPMM2"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Am^-3']">
        <admst:text format="U_AMPMM3"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Ohm m^2']">
        <admst:text format="U_OHMM2"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Ohm/sq']">
        <admst:text format="U_OSQM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Fm^-1']">
        <admst:text format="U_FARADMM1"/>
      </admst:when>
      <admst:when test="[attribute/[name='units']/value = 'Fm^-2']">
        <admst:text format="U_FARADMM2"/>
      </admst:when>

      <admst:otherwise>
        <admst:text format="U_UNKNOWN"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   processTerm
   given any node, run the associated template over it
   =================================================================-
  -->
  <admst:template match="processTerm" >
    <admst:apply-templates select="." match="%(adms/datatypename)">
      <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
    </admst:apply-templates>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   printTerm
   given any node, run the associated template over it and print
   =================================================================-
  -->
  <admst:template match="printTerm" >
    <admst:apply-templates select="." match="%(adms/datatypename)">
      <admst:text format="%(returned('returnedExpression')/value)"/>
    </admst:apply-templates>
  </admst:template>

  <!--
   =================================================================-
   handling of expression
   expression
   This template returns the expression passed to it in the select
   field
   It processes each element of the tree using a template of the
   same name as the datatype name.

   To understand what it's doing, be aware that the datatypenames
   that typically end up in the tree  are things like number,
   mapply_binary, mapply_unary, expression (implying recursion back
   into this template), ... (fill in, it would be good for this
   comment to document all the templates we can call)

   Each of the templates called does little more than return the C++
   representation of that type of data, and when we return the entire
   expression will be printed in C++
   =================================================================-
  -->
  <admst:template match="expression">
    <admst:apply-templates select="tree" match="%(adms/datatypename)" required="yes">
      <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
    </admst:apply-templates>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   number
   Print out a number, properly accounting for scaling unit suffixes
   =================================================================-
  -->
  <admst:template match="number">
    <admst:value-of select="value"/>
    <admst:choose>
      <admst:when test="[scalingunit='1']"><admst:return name="returnedExpression" value="%s"/></admst:when>
      <admst:when test="[scalingunit='E']"><admst:return name="returnedExpression" value="(%s*1.0e+18)"/></admst:when>
      <admst:when test="[scalingunit='P']"><admst:return name="returnedExpression" value="%s*1.0e+15"/></admst:when>
      <admst:when test="[scalingunit='T']"><admst:return name="returnedExpression" value="%s*1.0e+12"/></admst:when>
      <admst:when test="[scalingunit='G']"><admst:return name="returnedExpression" value="%s*1.0e+9"/></admst:when>
      <admst:when test="[scalingunit='M']"><admst:return name="returnedExpression" value="%s*1.0e+6"/></admst:when>
      <admst:when test="[scalingunit='k']"><admst:return name="returnedExpression" value="%s*1.0e+3"/></admst:when>
      <admst:when test="[scalingunit='h']"><admst:return name="returnedExpression" value="%s*1.0e+2"/></admst:when>
      <admst:when test="[scalingunit='D']"><admst:return name="returnedExpression" value="%s*1.0e+1"/></admst:when>
      <admst:when test="[scalingunit='d']"><admst:return name="returnedExpression" value="%s*1.0e-1"/></admst:when>
      <admst:when test="[scalingunit='c']"><admst:return name="returnedExpression" value="%s*1.0e-2"/></admst:when>
      <admst:when test="[scalingunit='m']"><admst:return name="returnedExpression" value="%s*1.0e-3"/></admst:when>
      <admst:when test="[scalingunit='u']"><admst:return name="returnedExpression" value="%s*1.0e-6"/></admst:when>
      <admst:when test="[scalingunit='n']"><admst:return name="returnedExpression" value="%s*1.0e-9"/></admst:when>
      <admst:when test="[scalingunit='A']"><admst:return name="returnedExpression" value="%s*1.0e-10"/></admst:when>
      <admst:when test="[scalingunit='p']"><admst:return name="returnedExpression" value="%s*1.0e-12"/></admst:when>
      <admst:when test="[scalingunit='f']"><admst:return name="returnedExpression" value="%s*1.0e-15"/></admst:when>
      <admst:when test="[scalingunit='a']"><admst:return name="returnedExpression" value="%s*1.0e-18"/></admst:when>
      <admst:otherwise>
        <admst:value-of select="scalingunit"/>
        <admst:fatal format="%s%s: scaling unit not supported\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   mapply_unary
   This template handles unary operators, printing out the result
   surrounded by parentheses
   =================================================================-
  -->
  <admst:template match="mapply_unary">
    <admst:if test="[name='plus']"> <admst:variable name="op" select="+"/> </admst:if>
    <admst:if test="[name='minus']"> <admst:variable name="op" select="-"/> </admst:if>
    <admst:if test="[name='not']"> <admst:variable name="op" select="!"/> </admst:if>
    <admst:if test="[name='bw_not']"> <admst:variable name="op" select="~"/> </admst:if>
    <admst:value-of select="arg1/adms/datatypename"/>
    <admst:apply-templates select="arg1" match="%s" required="yes">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="expression" select="($op%s)"/>
    </admst:apply-templates>

    <admst:return name="returnedExpression" value="$expression"/>

  </admst:template>

  <!--
   =================================================================-
   mapply_binary
   This template handles binary operators, printing out the C++
   version surrounded by parentheses
   =================================================================-
  -->
  <admst:template match="mapply_binary">
    <admst:apply-templates select="arg1" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a1" select="%s"/>
    </admst:apply-templates>
    <admst:apply-templates select="arg2" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a2" select="%s"/>
    </admst:apply-templates>

    <admst:choose>
      <!-- addition -->
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
            <admst:variable name="expression" select="0.0"/>
          </admst:when>
          <admst:when test="[arg1/math/value=0.0]">
            <admst:variable name="expression" select="(+%($a2))"/>
          </admst:when>
          <admst:when test="[arg2/math/value=0.0]">
            <admst:variable name="expression" select="(%($a1))"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1+$a2)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <!-- subtraction -->
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
            <admst:variable name="expression" select="0.0"/>
          </admst:when>
          <admst:when test="[arg1/math/value=0.0]">
            <admst:variable name="expression" select="(-%($a2))"/>
          </admst:when>
          <admst:when test="[arg2/math/value=0.0]">
            <admst:variable name="expression" select="(%($a1))"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1-$a2)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[(arg1/math/value=0.0)or(arg2/math/value=0.0)]">
            <admst:variable name="expression" select="0.0"/>
          </admst:when>
          <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="expression" select="1.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1*$a2)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:choose>
          <admst:when test="[arg1/math/value=0.0]">
            <admst:variable name="expression" select="0.0"/>
          </admst:when>
          <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
            <admst:variable name="expression" select="1.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1/$a2)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="expression" select="($a1%(bname(.)/[name='bname']/value)$a2)"/>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   mapply_ternary
   Given a ternary operator (cond)?yes:no
   format for C++
   =================================================================-
  -->
  <admst:template match="mapply_ternary">
    <admst:apply-templates select="arg1" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a1" select="%s"/>
    </admst:apply-templates>
    <admst:apply-templates select="arg2" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a2" select="%s"/>
    </admst:apply-templates>
    <admst:apply-templates select="arg3" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a3" select="%s"/>
    </admst:apply-templates>
    <admst:choose>
      <admst:when test="[$globalCurrentScope='sensitivity']">
        <admst:apply-templates select="arg2" match="recursiveDetectParameterDependence">
          <admst:variable name="arg2Pdep" value="%(returned('isDependent')/value)"/>
        </admst:apply-templates>
        <admst:apply-templates select="arg3" match="recursiveDetectParameterDependence">
          <admst:variable name="arg3Pdep" value="%(returned('isDependent')/value)"/>
        </admst:apply-templates>
        <admst:choose>
          <admst:when test="[$arg2Pdep = 'yes' or $arg3Pdep='yes']">
            <admst:variable name="expression" select="adms_ternary_op&lt;AdmsSensFadType&gt;($a1,$a2,$a3)"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1?$a2:$a3)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:apply-templates select="arg2" match="recursiveDetectProbeDependence">
          <admst:variable name="arg2Pdep" value="%(returned('isDependent')/value)"/>
        </admst:apply-templates>
        <admst:apply-templates select="arg3" match="recursiveDetectProbeDependence">
          <admst:variable name="arg3Pdep" value="%(returned('isDependent')/value)"/>
        </admst:apply-templates>
        <admst:choose>
          <admst:when test="[$arg2Pdep = 'yes' or $arg3Pdep='yes']">
            <admst:variable name="expression" select="adms_ternary_op&lt;AdmsFadType&gt;($a1,$a2,$a3)"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1?$a2:$a3)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   assignment
   Given an assignment, format it for C++

   Special Case:  If the assignment happens to be one that uses
   $limit, we don't emit anything.  Those special things are handled
   differently.
   =================================================================-
  -->
  <admst:template match="assignment">
    <admst:assert test="adms[datatypename='assignment']" format="assignment template called with something that is not an assignment\n"/>
    <admst:choose>
    <admst:when test="[nilled(rhs/function/[name='\$limit'])]">
      <admst:variable name="saveTemplateUse" select="$globalMustUseTemplate"/>
      <admst:variable name="saveScalarForce" select="$globalMustForceScalar"/>
      <!-- if the lhs has any probe dependence recorded, then it's a Fad type -->
      <admst:if test="[exists(lhs/probe) and $globalCurrentScope!='sensitivity']">
        <admst:variable name="globalMustUseTemplate" select="yes"/>
      </admst:if>
      <admst:if test="[$globalCurrentScope='sensitivity']">
        <admst:apply-templates select="lhs" match="collectParamDependence"/>
        <admst:if test="[exists(lhs/#Pdependent)]">
          <admst:variable name="globalMustUseTemplate" select="yes"/>
        </admst:if>
      </admst:if>
      <!-- Bleh.  Sometimes, even if the lhs is not probe dependent, the
           rhs could depend on a variable that is *sometimes*
           probe-dependent but isn't at the moment (as, for example,
           when a temporary variable is sometimes used to store the
           results of probe-dependent computations, and sometimes just
           plain constant expressions).  In this case, both lhs/probe
           and rhs/probe are nilled because the overall rhs expression
           has no probe dependence, but some variable in it has a
           non-nilled probe:  That means that the RHS has a Fad typed
           variable in it, that the current value stored in that
           variable has NO dependence on any probes, but the LHS is a
           double.  This requires that we generate all references to the
           Fad Variable with ".val() calls on the RHS. -->
      <admst:text format="%(printTerm(lhs)) "/>
      <!-- Make sure we check parameter dependence of rhs and lhs variables-->
      <admst:if test="[$globalCurrentScope='sensitivity']">
        <admst:apply-templates select="rhs" match="collectParamDependence"/>
      </admst:if>
      <admst:if test="[(nilled(lhs/probe) and nilled(rhs/probe) and $globalCurrentScope!='sensitivity') or ($globalCurrentScope='sensitivity' and not(exists(lhs/#Pdependent)) and not(exists(rhs/#Pdependent)))]">
        <admst:variable name="globalMustForceScalar" select="yes"/>
      </admst:if>
      <admst:text format="= %(printTerm(rhs));\n"/>

      <admst:variable name="globalMustUseTemplate" select="$saveTemplateUse"/>
      <admst:variable select="$saveScalarForce" name="globalMustForceScalar"/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="." match="limiterAssignment"/>
    </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   limiterAssignment
   Handle special case output for assignments that involve limiters
   These require lots of extra output, and it's only part of the deal.
   =================================================================-
  -->
  <admst:template match="limiterAssignment">
    <admst:choose>
      <admst:when test="[$globalCurrentScope='sensitivity']">
        <!-- The probeVars for "typed" limiters must be pre-multiplied by the
             type variable anyway, so for sensitivity (which doesn't do
             limiting) just do the assignment -->
        <admst:text format="%(printTerm(lhs)) = probeVars[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];\n\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="\n\n//%(printTerm(lhs)) = %(rhs);\n"/>
        <admst:text format="if (getDeviceOptions().voltageLimiterFlag)\n"/>
        <admst:text format="{\n"/>
        <admst:text format="  int icheck=0;\n"/>
        <admst:choose>
          <admst:when test="[rhs/function[name='\$limit']/arguments[2]/datatypename='string']">
            <admst:choose>
              <!-- the string could be "pnjlim" or "fetlim" -->
              <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='pnjlim' or rhs/function[name='\$limit']/arguments[2]/value='typedpnjlim']">
                <!-- handle "pnjlim" -->
                <admst:text format="  %(printTerm(lhs))_limited = devSupport.pnjlim(%(printTerm(lhs))_limited,%(printTerm(lhs))_old,%(printTerm((rhs/function[name='\$limit']/arguments[3]))),%(printTerm((rhs/function[name='\$limit']/arguments[4]))),&amp;icheck);\n"/>
              </admst:when>
              <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='pnjlim_new' or rhs/function[name='\$limit']/arguments[2]/value='typedpnjlim_new']">
                <!-- handle "pnjlim_new" -->
                <admst:text format="  %(printTerm(lhs))_limited = devSupport.pnjlim_new(%(printTerm(lhs))_limited,%(printTerm(lhs))_old,%(printTerm((rhs/function[name='\$limit']/arguments[3]))),%(printTerm((rhs/function[name='\$limit']/arguments[4]))),&amp;icheck);\n"/>
              </admst:when>
              <!-- if "fetlim" we would do something else, but for now nothing... -->
              <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='fetlim' or rhs/function[name='\$limit']/arguments[2]/value='typedfetlim']">
                <admst:warning format="Warning: fetlim not implemented, ignoring."/>
              </admst:when>
              <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='dummy' or rhs/function[name='\$limit']/arguments[2]/value='typeddummy']">
                <admst:text format="  // dummy limiting for initialization purposes\n"/>
              </admst:when>
              <!-- KLUDGE ALERT!  ADMS has a bug.  It does not properly allow us to
                   pass the name of the analog function to the $limit function as it
                   should, and pukes an error saying "identifier never declared."
                   To get something usable, I am going to support passing a string
                   other than pnjlim or fetlim, and treat it as an analog function
                   name if so.  This is NOT standard verilog and needs fixing. -->

              <admst:otherwise>
                <admst:text format="  %(printTerm(lhs))_limited = AnalogFunctions::%(rhs/function[name='\$limit']/arguments[2]/value)(%(printTerm(lhs))_limited,%(printTerm(lhs))_old"/>
                <admst:if test="[count(rhs/function[name='\$limit']/arguments)>2]">
                  <admst:choose>
                    <admst:when test="[rhs/function[name='\$limit']/arguments[3]/value = 'typed']">
                      <admst:if test="[count(rhs/function[name='\$limit']/arguments)>4]">
                        <admst:text format=","/>
                        <admst:join select="rhs/function[name='\$limit']/arguments[position(.)>4]" separator=",">
                          <admst:text format="%(printTerm(.))"/>
                        </admst:join>
                      </admst:if>
                    </admst:when>
                    <admst:otherwise>
                      <admst:text format=","/>
                      <admst:join select="rhs/function[name='\$limit']/arguments[position(.)>2]" separator=",">
                        <admst:text format="%(printTerm(.))"/>
                      </admst:join>
                    </admst:otherwise>
                  </admst:choose>
                </admst:if>
                <admst:text format=");\n"/>
                <admst:text format="if (%(printTerm(lhs))_limited != %(printTerm(lhs))_orig)\n"/>
                <admst:text  format="{\n"/>
                <admst:text  format="icheck=1;\n"/>
                <admst:text  format="}\n"/>
              </admst:otherwise>

            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:text format="  %(printTerm(lhs))_limited = AnalogFunctions::%(rhs/function[name='\$limit']/arguments[2])((%(printTerm(lhs))_limited,%(printTerm(lhs))_old"/>
            <admst:if test="[count(rhs/function[name='\$limit']/arguments)>2]">
              <admst:text format=","/>
              <admst:join select="rhs/function[name='\$limit']/arguments[position(.)>2]" separator=",">
                <admst:text format="%(printTerm(.))"/>
              </admst:join>
            </admst:if>
            <admst:text format=");\n"/>
          </admst:otherwise>
        </admst:choose>
        <admst:text format="  if (icheck == 1)\n"/>
        <admst:text format="     origFlag = false;\n"/>

        <admst:text format="  if (!origFlag)\n  {\n"/>
        <admst:text format="    probeDiffs[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)] = %(printTerm(lhs))_limited - %(printTerm(lhs))_orig;\n"/>
        <admst:text format="    probeVars[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)] += probeDiffs[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];\n"/>
        <admst:text format="  }\n"/>
        <admst:text format="}\n"/>
        <admst:text format="%(printTerm(lhs)) = probeVars[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];\n\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
<!--
   =================================================================-
   contribution
   Given a contribution, format it for xyce's updateIntermediateVars

   This template is complicated by the need to compute Jdxp terms
   when we are working with any RHS that involves limited probes.
   =================================================================-
  -->
  <admst:template match="contribution">
    <!-- Do sanity check to make sure we're actually processing a contribution
    -->
    <admst:assert test="adms[datatypename='contribution']" format="contribution template called with something that is not a contribution\n"/>

    <!-- Error out if this module uses contribution types we don't grok -->
    <!--
    <admst:if test="[lhs/discipline/potential=lhs/nature and rhs/datatypename='expression' and not(rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0'))]">
      <admst:error format="this version of the Xyce ADMS interface does not support contributions into voltages unless one is setting them to 0 or 0.0.  Attempt to do %(lhs) &lt; %(rhs) failed\n"/>
    </admst:if>
    -->

    <!-- force template functions used on rhs to be explicitly instantiated -->
    <admst:variable name="saveTemplateUse" select="$globalMustUseTemplate"/>
    <admst:variable name="globalMustUseTemplate" select="yes"/>

    <!-- actual contribution processing done here -->
    <admst:text format="// %(lhs) &lt;+ %(rhs)\n"/>

    <!-- static and dynamic go to different places (F vs. Q) -->
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:variable name="mode" select="dynamic"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="mode" select="static"/>
      </admst:otherwise>
    </admst:choose>


    <admst:choose>

      <!-- Contributions into potential sources with rhs 0 are only
           used for node collapse in set-up, so do nothing -->
      <admst:when test="[lhs/discipline/potential=lhs/nature and (rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0'))]">
        <admst:text format="// do nothing at all\n"/>
      </admst:when>

      <!-- Contributions into potential sources that are nonzero are
           really different.  In this case, we add/subtract the
           associated branch current from the pos and negative nodes,
           and also add to the branch equation -->
      <admst:when test="[lhs/discipline/potential=lhs/nature]">

        <!-- do nothing if a noise term -->
        <admst:if test="[whitenoise='no' and flickernoise='no']">
          <!-- Positive and negative nodes get +/- the branch variable value -->
          <!-- But this is not done once for every contribution to a source,
               just once for each source!  So these terms will be done
               in the same finish-up operation mentioned below -->
          <admst:variable name="branchConstant" select="%(xyceBranchConstantName(lhs/branch)/[name='branchConstant']/value)"/>

          <admst:choose>
            <admst:when test="[count(module/@limitedProbes)>0 and not(nilled(rhs/probe/[#limited='yes'])) and not ($globalCurrenScope='sensitivity')]">
              <!-- Special processing when RHS involves limited probes -->
              <admst:text format="{\n"/>
              <admst:text format="AdmsFadType contribTemp;\n"/>
              <admst:text format="contribTemp = %(printTerm(rhs));\n"/>
              <admst:text format="%($mode)Contributions[%($branchConstant)] += contribTemp;\n"/>
              <admst:text format="Jdxp_%($mode)[$branchConstant] += "/>
              <admst:join select="rhs/probe[#limited='yes']" separator="+">
                <admst:text format="contribTemp.dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))*probeDiffs[%(xyceProbeConstantName(.)/[name='probeConstant']/value)]*probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)].dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))"/>
              </admst:join>
              <admst:text format=";\n"/>

            </admst:when>

            <admst:otherwise>
              <!-- this is the simple case, no limiting needed -->
              <!-- Branch equation gets + the RHS -->
              <admst:text format="%($mode)Contributions[%($branchConstant)] += %(printTerm(rhs));\n"/>
            </admst:otherwise>
          </admst:choose>

          <!-- There is one last contribution necessary, but we don't do it here.
               The branch equation also needs to get - the potential
               from the solution, but it should only get this once, and there
               could be multiple contributions to this potential.  We'll
               have to do it in a finish-up loop later -->
        </admst:if>
      </admst:when>

      <!-- Otherwise it's a contribution into flow source, which is
           the most most straightforward case -->
      <admst:otherwise>
        <!-- do nothing if a noise term -->
        <admst:if test="[whitenoise='no' and flickernoise='no']">
          <admst:variable name="pnode" select="%(lhs/branch/pnode)"/>
          <admst:variable name="pnodeConstant" select="%(xyceNodeConstantName($pnode)/[name='nodeConstant']/value)"/>
          <admst:variable name="nnode" select="%(lhs/branch/nnode)"/>
          <!-- special processing when contribution RHS involves limited
               probes.  We must compute the rhs of the contribution,
               but also generate the Jdxp terms-->
          <admst:choose>
            <admst:when test="[count(module/@limitedProbes)>0 and not(nilled(rhs/probe/[#limited='yes'])) and not($globalCurrentScope='sensitivity')]">
              <admst:text format="{\n"/>
              <admst:text format="AdmsFadType contribTemp;\n"/>
              <admst:text format="contribTemp= %(printTerm(rhs));\n"/>
              <admst:text format="%($mode)Contributions[$pnodeConstant] += contribTemp;\n"/>
              <admst:if test="$nnode[grounded='no']">
                <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
                <admst:text format="%($mode)Contributions[$nnodeConstant] -= contribTemp;\n"/>
              </admst:if>

              <admst:text format="\n"/>

              <!-- generate the Jdxp's:
                   Jdxp[pnode]+= d(rhs)/d(probe)*deltaprobe*dlimitedprobe/dprobe

                   The "dlimitedprobe/dprobe" thing is to handle cases
                   where there could be a minus sign introduced by limiting,
                   which can happen with PNP/PMOS vs. NPN/NMOS limiting hacks.

                   Similar for Jdxp[nnode]
                   -->
              <admst:text format="Jdxp_%($mode)[$pnodeConstant] += "/>
              <admst:join select="rhs/probe[#limited='yes']" separator="+">
                <admst:text format="contribTemp.dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))*probeDiffs[%(xyceProbeConstantName(.)/[name='probeConstant']/value)]*probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)].dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))"/>
              </admst:join>
              <admst:text format=";\n"/>
              <admst:if test="$nnode[grounded='no']">
                <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
                <admst:text format="Jdxp_%($mode)[$nnodeConstant] -= "/>
                <admst:join select="rhs/probe[#limited='yes']" separator="+">
                  <admst:text format="contribTemp.dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))*probeDiffs[%(xyceProbeConstantName(.)/[name='probeConstant']/value)]*probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)].dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))"/>
                </admst:join>
                <admst:text format=";\n"/>
              </admst:if>
              <admst:text format="}\n"/>
            </admst:when>

            <!-- When no limiting, this is much simpler: Just output RHS -->
            <admst:otherwise>
              <admst:text format="%($mode)Contributions[$pnodeConstant] += %(printTerm(rhs));\n"/>
              <admst:if test="$nnode[grounded='no']">
                <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
                <admst:text format="%($mode)Contributions[$nnodeConstant] -= %(printTerm(rhs));\n"/>
              </admst:if>
            </admst:otherwise>
          </admst:choose>
        </admst:if>
          <!-- we will handle only very specific types of  noise contributions,
               those whose RHS is strictly a single noise function.  This is
               enforced by the assertions in xyceNoiseContributionName.  Get
               its name -->
        <admst:if test="[(whitenoise='yes' or flickernoise='yes') and not($globalCurrentScope='sensitivity')]">
          <admst:variable name="theNoiseContributionName" select="%(xyceNoiseContributionName(.))"/>
          <admst:text format="if (getSolverState().noiseFlag)\n{\n"/>
          <!-- now force scalar, because we're assigning to a double value -->
          <admst:variable name="saveForceScalar" select="$globalMustForceScalar"/>
          <admst:variable name="globalMustForceScalar" select="yes"/>
          <admst:text format="  noiseContribsPower[%(#noiseContIndex)]="/>
          <!-- extract the power argument, the first one-->
          <admst:text format=" %(printTerm(rhs/tree/arguments[1]));\n"/>
          <!-- flicker noise has an extra argument -->
          <admst:if test="[rhs/tree/name='flicker_noise']">
            <admst:text format="  noiseContribsExponent[%(#noiseContIndex)]="/>
            <admst:text format=" %(printTerm(rhs/tree/arguments[2]));\n"/>
          </admst:if>
          <admst:text format="}\n"/>
          <admst:variable name="globalMustForceScalar" select="$saveForceScalar"/>
        </admst:if>

      </admst:otherwise>
    </admst:choose>
    <admst:variable name="globalMustUseTemplate" select="$saveTemplateUse"/>
  </admst:template>

  <!--
   =================================================================-
   probe
   Given a probe, format it for xyce's updateIntermediateVars
   =================================================================-
  -->
  <admst:template match="probe">
<!--
    <admst:assert test="[nature!=discipline/flow]" format="Xyce ADMS interface does not yet support current probes.  %(.) not supported./n"/>
-->
    <admst:variable name="expression" select="(probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)])"/>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   variable
   given a variable, emit C++ reference thereto
   =================================================================-
  -->
  <admst:template match="variable">
    <admst:assert test="adms[datatypename='variable']" format="variable template called on non-variable\n"/>
    <admst:choose>
      <admst:when test="[scope='local']">
        <admst:variable name="expression" select="%(name)"/>
      </admst:when>
      <admst:when test="[scope='global_instance']">
        <admst:choose>
          <admst:when test="[($globalCurrentScope='instance' or exists(attribute[name='xyceAlsoModel'])) and not($globalCurrentScope='sensitivity')]">
            <admst:variable name="expression" select="%(name)"/>
          </admst:when>
          <admst:when test="[$globalCurrentScope='sensitivity']">
            <admst:choose>
              <admst:when test="[input='yes']">
                <admst:choose>
                  <admst:when test="[$globalSensitivityScope='model']">
                    <admst:if test="[not exists(attribute[name='xyceAlsoModel'])]">
                      <admst:fatal format="it is not legal to access instance variable %(name) in model context!  Our current scope is $globalCurrentScope, and we are generating $globalSensitivityScope code.\n"/>
                    </admst:if>
                    <admst:variable name="expression" select="modelPar_%(name)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expression" select="instancePar_%(name)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expression" select="instanceVar_%(name)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:fatal format="it is not legal to access instance variable %(name) outside of the instance class!  Our current scope is $globalCurrentScope\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[scope='global_model']">
        <admst:choose>
          <admst:when test="[$globalCurrentScope='model']">
            <admst:variable name="expression" select="%(name)"/>
          </admst:when>
          <admst:when test="[$globalCurrentScope='sensitivity']">
            <admst:choose>
              <admst:when test="[input='yes']">
                <admst:variable name="expression" select="modelPar_%(name)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expression" select="modelVar_%(name)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="(model_.%(name))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="Unknown variable scope for %(name): %(scope)\n"/>
      </admst:otherwise>
    </admst:choose>
    <admst:if test="[$globalMustForceScalar='yes' and (($globalCurrentScope!='sensitivity' and not(nilled(probe))) or ($globalCurrentScope='sensitivity' and exists(#Pdependent)) and type='real')]">
      <admst:variable name="expression" select="$expression.val()"/>
    </admst:if>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   function
   =================================================================-
  -->
  <admst:template match="function">
    <admst:choose>
      <admst:when test="[name='min']">
        <admst:variable name="expression" select="std::min"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <!-- if *ANY* argument depends on probes, can't use std::min, must
               use Sacado's overloaded min -->
          <admst:if test="[exists(math/dependency)]">
            <admst:if test="[((math/dependency='linear' or math/dependency='nonlinear') and $globalCurrentScope != 'sensitivity')]">
              <admst:variable name="expression" select="min"/>
            </admst:if>
          </admst:if>
          <admst:if test="[($globalCurrentScope='sensitivity' and exists(#Pdependent))]">
            <admst:variable name="expression" select="min"/>
          </admst:if>
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="realArgument">
            <admst:variable name="args" select="$args%(returned('argval')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:when>
      <admst:when test="[name='max']">
        <admst:variable name="expression" select="std::max"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <!-- if *ANY* argument depends on probes, can't use std::max, must
               use Sacado's overloaded max -->
          <admst:if test="[exists(math/dependency)]">
            <admst:if test="[((math/dependency='linear' or math/dependency='nonlinear') and $globalCurrentScope != 'sensitivity')]">
              <admst:variable name="expression" select="max"/>
            </admst:if>
          </admst:if>
          <admst:if test="[($globalCurrentScope='sensitivity' and exists(#Pdependent))]">
            <admst:variable name="expression" select="max"/>
          </admst:if>
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="realArgument">
            <admst:variable name="args" select="$args%(returned('argval')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:when>
      <admst:when test="[name='absdelay']">
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="FIXMEabsdelay(%(returned('returnedExpression')/value))"/>
        </admst:apply-templates>
      </admst:when>
      <!-- DDT is a null function in Xyce we'll load such things into
           dynamic contributions, and those will be differentiated elsewhere -->
      <admst:when test="[name='ddt']">
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="(%(returned('returnedExpression')/value))"/>
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='\$given' or name='\$param_given']">
        <admst:variable name="arg1" select="%(arguments[1])"/>
        <admst:assert test="$arg1[datatypename='variable' and input='yes']" format="%(name): argument is not a parameter\n"/>
        <admst:choose>
          <admst:when test="$arg1/[parametertype='model']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope = 'model']">
                <admst:variable name="expression" select="given(&quot;$arg1&quot;)"/>
              </admst:when>
              <admst:when test="[$globalCurrentScope = 'instance']">
                <admst:variable name="expression" select="(model_.given(&quot;$arg1&quot;))"/>
              </admst:when>
              <admst:when test="[$globalCurrentScope = 'sensitivity']">
                <admst:variable name="expression" select="modelPar_given_$arg1"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:when test="$arg1/[parametertype='instance']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope = 'instance']">
                <admst:variable name="expression" select="given(&quot;$arg1&quot;)"/>
              </admst:when>
              <admst:when test="[$globalCurrentScope = 'sensitivity']">
                <admst:variable name="expression" select="instancePar_given_$arg1"/>
              </admst:when>
              <admst:otherwise>
                <admst:fatal format="Attempt to use \$given() on an instance variable outside of instance scope\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:fatal format="%(name): should not be reached\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$temperature']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:choose>
          <admst:when test="[$globalCurrentScope='instance' or $globalCurrentScope='sensitivity']">
            <admst:variable name="expression" select="admsTemperature"/>
          </admst:when>
          <!-- KLUDGE!!!!!! -->
          <!-- Assumes that when at model scope, $temperature is taken as
               the default temperature of the simulator. -->
          <!-- At instance scope, we use whatever Xyce passed in to
               updateTemperature for that instance. -->
          <admst:when test="[$globalCurrentScope='model']">
            <admst:variable name="expression" select="admsModTemp"/>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$mfactor']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:variable name="expression" select="FIXME_MFACTOR"/>
      </admst:when>
      <admst:when test="[name='\$vt']">
        <admst:choose>
          <admst:when test="[nilled(arguments)]">
            <admst:variable name="expression" select="adms_vt_nom"/>
          </admst:when>
          <admst:when test="arguments[count(.)=1]">
            <admst:apply-templates select="arguments[1]" match="processTerm">
              <admst:variable name="expression" select="adms_vt(%(returned('returnedExpression')/value))"/>
            </admst:apply-templates>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$scale']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:variable name="expression" select="FIXME_scale"/>
      </admst:when>
      <admst:when test="[name='\$abstime' or name='\$realtime']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
          <admst:choose>
            <admst:when test="[$globalCurrentScope='sensitivity']">
              <admst:variable name="expression" select="theInstance.getSolverState().currTime_"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="getSolverState().currTime_"/>
            </admst:otherwise>
          </admst:choose>
      </admst:when>
      <admst:when test="[name='ddx']">
        <admst:assert test="arguments[count(.)=2]" format="%(name): should have two arguments exactly\n"/>
        <admst:assert test="arguments[2]/adms[datatypename='probe']" format="%(name): second argument is not a probe\n"/>
        <admst:variable name="expression" select="FIXME: ddx(%(arguments[1]),%(arguments[2]))"/>
      </admst:when>
      <admst:when test="[name='floor']">
        <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
          <admst:choose>
            <admst:when test="[$globalCurrentScope='sensitivity']">
              <admst:apply-templates select="." match="recursiveDetectParameterDependence">
                <admst:variable name="isDependent" select="%(returned('isDependent')/value)"/>
                <admst:choose>
                  <admst:when test="[$isDependent='yes']">
                    <admst:variable name="expression" select="ADMSfloor($expression)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expression" select="floor($expression)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:apply-templates>
            </admst:when>
            <admst:otherwise>
              <admst:choose>
                <admst:when test="[exists(math/dependency) and (math/dependency='linear' or math/dependency='nonlinear')]">
                  <admst:variable name="expression" select="ADMSfloor($expression)"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expression" select="floor($expression)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:otherwise>
          </admst:choose>
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='ceil']">
        <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="%(returned('returnedExpression')/value))"/>
          <admst:choose>
            <admst:when test="[$globalCurrentScope='sensitivity']">
              <admst:apply-templates select="." match="recursiveDetectParameterDependence">
                <admst:variable name="isDependent" select="%(returned('isDependent')/value))"/>
                <admst:choose>
                  <admst:when test="[$isDependent='yes']">
                    <admst:variable name="expression" select="ADMSceil($expression)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="expression" select="ceil($expression)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:apply-templates>
            </admst:when>
            <admst:otherwise>
              <admst:choose>
                <admst:when test="[exists(math/dependency) and (math/dependency='linear' or math/dependency='nonlinear')]">
                  <admst:variable name="expression" select="ADMSceil($expression)"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="expression" select="ceil($expression)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:otherwise>
          </admst:choose>
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='\$simparam']">
        <admst:choose>
          <admst:when test="[arguments[1]/datatypename='string' and arguments[1]/value='gmin']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope='sensitivity']">
                <admst:variable name="expression" select="gmin"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expression" select="getDeviceOptions().gmin"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:assert test="arguments[count(.)=2]" format="Unrecognized simparam %(arguments[1]) and no expression provided.\n"/>
            <admst:apply-templates select="arguments[2]" match="processTerm">
              <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
            </admst:apply-templates>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='ln' or name='log' or name='sqrt']">
        <admst:variable name="expression" select="%(funcname(.)/[name='fname']/value)"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="realArgument">
            <admst:variable name="args" select="$args%(returned('argval')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="expression" select="%(funcname(.)/[name='fname']/value)"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="processTerm">
            <admst:variable name="args" select="$args%(returned('returnedExpression')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   string
   format a string for output
   =================================================================-
  -->
  <admst:template match="string">
    <admst:return name="returnedExpression" value="&quot;%(value)&quot;"/>
  </admst:template>

  <!--
   =================================================================-
   conditional
   output if/then/else
   =================================================================-
  -->
  <admst:template match="conditional">
    <admst:assert test="adms[datatypename='conditional']" format="conditional template called on something other than conditional\n"/>

    <admst:text format="if (%(printTerm(if)))\n"/>
    <!-- blocks will print their own braces, but we always want them -->
    <admst:text select="then/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="then" match="%(adms/datatypename)"/>
    <!-- blocks will print their own braces, but we always want them -->
    <admst:text select="then/adms[datatypename!='block']"  format="}\n"/>
    <admst:if test="else">
      <admst:text format="else\n"/>
      <admst:text select="else/adms[datatypename!='block']" format="{\n"/>
      <admst:apply-templates select="else" match="%(adms/datatypename)"/>
      <admst:text select="else/adms[datatypename!='block']"  format="}\n"/>
    </admst:if>
  </admst:template>

  <!--
   =================================================================-
   block
   output block
   =================================================================-
  -->
  <admst:template match="block">
    <admst:assert test="adms[datatypename='block']" format="block template called on something other than block\n"/>
    <admst:text select="[name!='']" format="//Begin block %(name)\n"/>
    <admst:text format="{\n"/>
    <admst:apply-templates select="item" match="%(adms/datatypename)"/>
    <admst:text format="}\n"/>
    <admst:text select="[name!='']" format="// End block %(name)\n"/>
  </admst:template>


  <!--
   =================================================================-
   blockvariable
     declare block-local variables
   =================================================================-
  -->
  <admst:template match="blockvariable">
    <admst:text format="//Block-local variables for block %(block/name)\n"/>
    <admst:for-each select="variable">
      <admst:if test="[$globalCurrentScope='sensitivity']">
        <admst:apply-templates select="." match="collectParamDependence"/>
      </admst:if>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
    </admst:for-each>
    <admst:text format="//End of Block-local variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   nilled
   do nothing, when nothing is found
   =================================================================-
  -->
  <admst:template match="nilled">
  </admst:template>

  <!--
   =================================================================-
   whileloop
   output while loop
   =================================================================-
  -->
  <admst:template match="whileloop">
    <admst:text format="while (%(printTerm(while)))\n"/>
    <admst:text select="whileblock/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="whileblock" match="%(adms/datatypename)"/>
    <admst:text select="whileblock/adms[datatypename!='block']" format="}\n"/>
  </admst:template>

  <!--
   =================================================================-
   forloop
   output for   loop
   =================================================================-
  -->
  <admst:template match="forloop">
    <admst:text format="for ("/>
    <admst:text format="%(printTerm(initial/lhs))=%(printTerm(initial/rhs));"/>
    <admst:text format="%(printTerm(condition));"/>
    <admst:text format="%(printTerm(update/lhs))=%(printTerm(update/rhs)) )"/>
    <admst:text select="forblock/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="forblock" match="%(adms/datatypename)"/>
    <admst:text select="forblock/adms[datatypename!='block']" format="}\n"/>
  </admst:template>
  <!--
   =================================================================-
   case
   output "case" statement
   =================================================================-
  -->
  <admst:template match="case">
    <admst:variable name="casecondition" path="case/tree"/>
    <admst:variable name="havedefault" select="no"/>
    <admst:if test="[count(caseitem[defaultcase='yes']) >0]">
      <admst:variable name="havedefault" select="yes"/>
    </admst:if>

    <admst:for-each select="caseitem[defaultcase='no']">
      <admst:text format="if ( "/>
      <admst:join select="condition" separator="||">
	<admst:apply-templates select="." match="%(datatypename)">
	  <admst:text format="%(printTerm($casecondition)) == (%(returned('returnedExpression')/value))"/>
	</admst:apply-templates>
      </admst:join>
      <admst:text format=")\n"/>
      <admst:apply-templates select="code" match="%(datatypename)" required="yes"/>
      <admst:text format="else\n"/>
    </admst:for-each>
    <admst:text select="[$havedefault='no']" format="{\n // no default\n}\n"/>
    <admst:for-each select="caseitem[defaultcase='yes']">
      <admst:apply-templates select="code" match="%(datatypename)" required="yes"/>
    </admst:for-each>
  </admst:template>


  <!--
   =================================================================-
   formatted_range
   Given a variable node, print out its range in a nicely formatted
   way, with open or closed bounds indicated.
   This is for pretty printing such as for HTML, not code generation.
   =================================================================-
  -->
  <admst:template match="formatted_range">
    <admst:choose>
      <admst:when test="[nilled(range)]">
        <admst:text format="No Range Specified"/>
      </admst:when>
      <admst:when test="[name!='pnp' and name!='npn']">
        <admst:apply-templates select="range" match="formatted_range2"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="Positive range"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   formatted_range2
   the actual guts of formatted range, but this one takes a single
   range node of the tree, not a variable (which can have multiple
   ranges
   =================================================================-
  -->
<admst:template match="formatted_range2">
  <admst:choose>
    <admst:when test="infexpr[hasspecialnumber='YES']">
      <admst:text format=" ] %(infexpr) "/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[infboundtype='range_bound_include']">
          <admst:text format="[ "/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="] "/>
        </admst:otherwise>
      </admst:choose>
      <admst:apply-templates select="infexpr" match="printTerm"/>
      <admst:text format=", "/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="supexpr[hasspecialnumber='YES']">
      <admst:text format=" %(supexpr) ["/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="supexpr" match="printTerm"/>
      <admst:choose>
	<admst:when test="[supboundtype='range_bound_include']">
	  <admst:text format=" ]"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format=" ["/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
</admst:template>

  <!--
   =================================================================-
   rangeCondition
   Given a range, generate the C++ condition that checks if it's
   exceeded/violated
   =================================================================-
  -->

<admst:template match="rangeCondition">
  <admst:choose>
    <admst:when test="[infexpr/hasspecialnumber='YES' and supexpr/hasspecialnumber='YES']">
      <admst:return name="doNothing" value="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="returnCondition" select="("/>
      <!-- Lower bound -->
      <admst:if test="infexpr[hasspecialnumber!='YES']">
        <admst:variable name="returnCondition" select="$returnCondition%(../name) &gt;"/>
        <admst:if test="[infboundtype='range_bound_include']">
          <admst:variable name="returnCondition" select="$returnCondition="/>
        </admst:if>
        <admst:variable name="returnCondition" select="$returnCondition%(processTerm(infexpr)/[name='returnedExpression']/value)"/>
        <admst:if test="supexpr[hasspecialnumber!='YES']">
          <admst:variable name="returnCondition" select="$returnCondition &amp;&amp; "/>
        </admst:if>
      </admst:if>

      <!-- upper bound -->
      <admst:if test="supexpr[hasspecialnumber!='YES']">
        <admst:variable name="returnCondition" select="$returnCondition%(../name) &lt;"/>
        <admst:if test="[supboundtype='range_bound_include']">
          <admst:variable name="returnCondition" select="$returnCondition="/>
        </admst:if>
        <admst:variable name="returnCondition" select="$returnCondition%(processTerm(supexpr)/[name='returnedExpression']/value) "/>
      </admst:if>
      <admst:variable name="returnCondition" select="$returnCondition)"/>

      <!-- now decide whether this is an include condition or exclude: -->
      <admst:if test="[type='include']">
        <admst:variable name="returnCondition" select="!($returnCondition)"/>
      </admst:if>
      <admst:return name="doNothing" value="no"/>
      <admst:return name="returnCondition" value="$returnCondition"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

  <!--
   =================================================================-
   check_range
   Given a variable node, generate code to check the variable against
   the range.

   The range of the variable is assumed non-nilled, so the caller
   must check first before calling this.
   =================================================================-
  -->

<admst:template match="check_range">
  <admst:choose>
    <!-- first special case: both upper and lower are special, meaning that
         there really is no range to bother checking -->
    <admst:when test="[range/infexpr/hasspecialnumber='YES' and range/supexpr/hasspecialnumber='YES']">
      <!-- do nothing -->
    </admst:when>
    <admst:otherwise>
      <!-- we have a range to check -->
      <admst:text format="  if ( "/>
      <admst:text format="("/>
      <!-- there may be several ranges specified, some included, some excluded.
           gotta be careful -->
      <admst:join select="range[infexpr/hasspecialnumber!='YES' or supexpr/hasspecialnumber!='YES']" separator=" || ">
        <admst:apply-templates select="." match="rangeCondition">
          <admst:text format="%(returned('returnCondition')/value)"/>
        </admst:apply-templates>
      </admst:join>
      <admst:text format=") )\n  {\n    UserError0(*this) &lt;&lt; &quot;$nameSpace: Parameter %(name) value &quot; &lt;&lt; %(name) &lt;&lt; &quot; "/>
      <admst:join select="range" separator=" or ">
        <admst:text select="[type='include']" format="out of range"/>
        <admst:text select="[type='exclude']" format="in excluded range"/>
        <admst:text format=" %(formatted_range2(.))"/>
      </admst:join>
      <admst:text format="&quot;;\n  }\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- map binary operators onto C++ symbols -->
<admst:template match="bname">
  <admst:choose>
    <admst:when test="[name='bw_equr']">
      <admst:return name="bname" value="^~"/>
    </admst:when>
    <admst:when test="[name='bw_equl']">
      <admst:return name="bname" value="~^"/>
    </admst:when>
    <admst:when test="[name='bw_xor']">
      <admst:return name="bname" value="^"/>
    </admst:when>
    <admst:when test="[name='bw_or']">
      <admst:return name="bname" value="|"/>
    </admst:when>
    <admst:when test="[name='bw_and']">
      <admst:return name="bname" value="&amp;"/>
    </admst:when>
    <admst:when test="[name='or']">
      <admst:return name="bname" value="||"/>
    </admst:when>
    <admst:when test="[name='and']">
      <admst:return name="bname" value="&amp;&amp;"/>
    </admst:when>
    <admst:when test="[name='equ']">
      <admst:return name="bname" value="=="/>
    </admst:when>
    <admst:when test="[name='notequ']">
      <admst:return name="bname" value="!="/>
    </admst:when>
    <admst:when test="[name='lt']">
      <admst:return name="bname" value="&lt;"/>
    </admst:when>
    <admst:when test="[name='lt_equ']">
      <admst:return name="bname" value="&lt;="/>
    </admst:when>
    <admst:when test="[name='gt']">
      <admst:return name="bname" value="&gt;"/>
    </admst:when>
    <admst:when test="[name='gt_equ']">
      <admst:return name="bname" value="&gt;="/>
    </admst:when>
    <admst:when test="[name='shiftr']">
      <admst:return name="bname" value="&gt;&gt;"/>
    </admst:when>
    <admst:when test="[name='shiftl']">
      <admst:return name="bname" value="&lt;&lt;"/>
    </admst:when>
    <admst:when test="[name='multmod']">
      <admst:return name="bname" value="%"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="variable type %(name) unknown\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="funcname">
  <admst:choose>
    <admst:when test="[name='abs']">
      <admst:variable name="expression" select="fabs"/>
    </admst:when>
    <admst:when test="[name='\$shrinkl']">
      <admst:variable name="expression" select="shrinkl"/>
    </admst:when>
    <admst:when test="[name='\$shrinka']">
      <admst:variable name="expression" select="shrinka"/>
    </admst:when>
    <admst:when test="[name='log']">
      <admst:variable name="expression" select="(1.0/log(10.0))*log"/>
    </admst:when>
    <admst:when test="[name='ln']">
      <admst:variable name="expression" select="log"/>
    </admst:when>
    <admst:when test="[name='limexp']">
      <admst:choose>
        <admst:when test="[$globalMustUseTemplate='no']">
          <admst:variable name="expression" select="limexp"/>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[$globalCurrentScope='sensitivity']">
              <admst:variable name="expression" select="limexp&lt;AdmsSensFadType&gt;"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="limexp&lt;AdmsFadType&gt;"/>
            </admst:otherwise>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='\$limexp']">
      <admst:choose>
        <admst:when test="[$globalMustUseTemplate='no']">
          <admst:variable name="expression" select="limexp"/>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[$globalCurrentScope='sensitivity']">
              <admst:variable name="expression" select="limexp&lt;AdmsSensFadType&gt;"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="limexp&lt;AdmsFadType&gt;"/>
            </admst:otherwise>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[$globalMustUseTemplate='no' or class!='analog']">
          <admst:choose>
            <admst:when test="[class='analog']">
              <admst:choose>
                <admst:when test="[$globalCurrentScope!='AF']">
                  <admst:variable name="expression" select="AnalogFunctions::%(name)"/>
                </admst:when>
                <admst:when test="[$globalCurrentScope='AF']">
                  <!-- If we call an analog function from within another,
                       make sure to force the same instantiation? -->
                  <admst:variable name="expression" select="%(name)&lt;ScalarT&gt;"/>
                </admst:when>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="%(name)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <!-- globalMustUseTemplate=yes, apparently -->
          <admst:choose>
            <admst:when test="[class='analog']">
              <!-- analog functions are in their own class, and the model
                   class has an instance of that. -->
              <admst:choose>
                <!-- if we're in the AF class, these functions are accessible
                     just by their names -->
                <admst:when test="[$globalCurrentScope='AF']">
                  <admst:variable name="expression" select="%(name)&lt;WRONG&gt;"/>
                </admst:when>
                <admst:when test="[$globalCurrentScope='model' or $globalCurrentScope='instance']">
                  <admst:variable name="expression" select="AnalogFunctions::%(name)&lt;AdmsFadType&gt;"/>
                </admst:when>
                <!-- when we're in instance class, have to reference through the
                     model -->
                <admst:when test="[$globalCurrentScope='sensitivity']">
                  <admst:variable name="expression" select="AnalogFunctions::%(name)&lt;AdmsSensFadType&gt;"/>
                </admst:when>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="%(name)&lt;AdmsFadType&gt;"/>
            </admst:otherwise>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
  <admst:return name="fname" value="$expression"/>
</admst:template>

<!-- callfunction: handle $strobe -->
<admst:template match="callfunction">
  <admst:choose>
    <admst:when test="function[name='\$strobe']">
      <admst:text format="std::cerr "/>
      <admst:for-each select="function/arguments">
      <admst:text format=" &lt;&lt; %(printTerm(.))"/>
      </admst:for-each>
      <admst:text format=" &lt;&lt;  std::endl; \n"/>
    </admst:when>
    <admst:when test="function[name='\$finish']">
      <admst:choose>
        <admst:when test="[$globalCurrentScope ='sensitivity']">
          <admst:text format=" UserError0(theInstance) &lt;&lt; &quot;%(function/name) called.&quot; &lt;&lt; std::endl; \n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format=" UserError0(*this) &lt;&lt; &quot;%(function/name) called.&quot; &lt;&lt; std::endl; \n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="function/name"/>
      <admst:text format="%s: not supported by this interface\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>



  <!--
   =================================================================-
   realArgument
   format a function argument to make sure that it is a real quantity
   when emitted.

   This is designed to be used such cases as
   real foo;
   integer bar;
   foo=ln(bar);
   which should wind up emitted as
   double foo;
   integer bar;
   foo=log(static_cast<double>(bar));

   This is especially important on systems like Windows.

   This may also be used to handle things like this:
   real foo;
   real bar;
   bar=max(foo,0);

   C++ hates having the integer constant as the second argument of max
   on most systems.

   What we do here is check that if the argument is a constant or
   integer variable.  If so, wrap the thing in a static cast first.
   Otherwise, just emit as is.

   When called, the current node is the argument.
   =================================================================-
  -->

  <admst:template match="realArgument">
    <admst:choose>
      <admst:when test="[datatypename='number' or (datatypename='variable' and type='integer')]">
        <admst:variable name="localArg" select="static_cast&lt;double&gt;(%(processTerm(.)/[name='returnedExpression']/value))" />
      </admst:when>
      <admst:otherwise>
        <admst:variable name="localArg" select="%(processTerm(.)/[name='returnedExpression']/value)" />
      </admst:otherwise>
    </admst:choose>
    <admst:return name="argval" value="$localArg"/>
  </admst:template>

 <!--
   =================================================================-
   generateEvaluateModelEquationsArgs

   to avoid doing all this mess over and over again, with possibility
   of mismatch, collect up in one place If global variable
   "globalDeclareEMEVars" is set, emit types with variable names (for
   function definition/declaration).  If not, just generate variable
   names (for function call)

   In this version, we're very specifically emitting declarations JUST
   for sensitivity, not for a general version.
   =================================================================-
 -->
 <admst:template match="generateEvaluateModelEquationsArgs">
   <!-- don't generate these if not declaring, because the caller
        might need to add things like "in." or "mod." to them. -->
   <admst:if test="[$globalDeclareVars='yes']">
     <admst:text format="std::vector &lt;double&gt; &amp; probeVars,\n"/>
     <admst:text format="// probe constants\n"/>

     <admst:if test="[count(probe)>0]">
       <admst:join select="probe" separator=",\n">
         <admst:text format="const int "/>
         <admst:text format="%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
       </admst:join>
       <admst:text format=",\n"/>
     </admst:if>
     <admst:if test="[count(@extraProbeBranches)>0]">
       <admst:join select="@extraProbeBranches" separator=",\n">
         <admst:text format="const int "/>
         <admst:text format="%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)"/>
       </admst:join>
       <admst:text format=",\n"/>
     </admst:if>

     <admst:text format="// node constants\n"/>

     <admst:join select="node[grounded='no']" separator=",\n">
       <admst:text format="const int "/>
       <admst:text format="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
     </admst:join>
     <admst:if test="[count(@extraUnknowns)>0]">
       <admst:text format=",\n"/>
       <admst:join select="@extraUnknowns" separator=",\n">
         <admst:text format="const int "/>
         <admst:text format="%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
       </admst:join>
     </admst:if>
   </admst:if>
   <admst:text format=",\n"/>

   <!-- now generate the instance and model parameters and variables -->
   <admst:apply-templates select="." match="generateInstanceAndModelArgs"/>

   <!-- don't generate these if not declaring, because the caller
        might need to add things like "in." or "mod." to them. -->
   <admst:if test="[$globalDeclareVars='yes']">
     <admst:text format="// basic variables\n"/>
     <admst:text format=" double admsTemperature"/>
     <admst:text format=", double adms_vt_nom"/>
     <admst:text format=", double gmin"/>
     <admst:text format=", std::vector &lt;AdmsSensFadType&gt; &amp; staticContributions"/>
     <admst:text format=", std::vector &lt;AdmsSensFadType&gt; &amp; dynamicContributions"/>
     <!-- YUCK!  Went through all that trouble to duplicate the instance vars
          and here we are passing an instance pointer!  Why?  Only because
          UserError0 takes an instance as argument.  DO NOT EVER USE ANYTHING
          FROM THE INSTANCE PASSED in evaluateModelEquations! -->
     <admst:text format=", const Instance &amp; theInstance"/>
   </admst:if>
</admst:template>

 <!--
   =================================================================-
   generateInstanceAndModelArgs

   This method, called both by generateEvaluateModelEquationsArgs
   and in declarations/definition of evaluateInitialInstance, centralizes
   declaration or call for instance parameters, model parameters, instance
   variables and model variables.

It calls generateInstanceArgs and generateModelArgs.

   In this version, we're very specifically emitting declarations JUST
   for sensitivity, not for a general version.
   =================================================================-
 -->

<admst:template  match="generateInstanceAndModelArgs">
  <admst:variable name="iGeneratedArgs" value="no"/>
  <admst:apply-templates select="." match="generateInstanceArgs">
    <admst:if test="[returned('iGeneratedArgs')/value = 'yes']">
      <admst:variable name="iGeneratedArgs" value="yes"/>
      <admst:text format=",\n"/>
    </admst:if>
  </admst:apply-templates>
  <admst:apply-templates select="." match="generateModelArgs">
    <admst:if test="[returned('iGeneratedArgs')/value = 'yes']">
      <admst:variable name="iGeneratedArgs" value="yes"/>
      <admst:text format=",\n"/>
    </admst:if>
  </admst:apply-templates>
  <admst:return name="iGeneratedArgs" value="$iGeneratedArgs"/>
</admst:template>

 <!--
   =================================================================-
   generateInstanceArgs

   This method, called by generateEvaluateModelEquationsArgs
   centralizes declaration or call for instance parameters and instance
   variables.

   In this version, we're very specifically emitting declarations JUST
   for sensitivity, not for a general version.
   =================================================================-
 -->
 <admst:template match="generateInstanceArgs">
   <admst:variable name="iGeneratedArgs" select="no" />
   <admst:if test="[exists( variable[parametertype='instance' and input='yes' and type='real']) or exists( variable[parametertype='instance' and input='no' and exists(attribute[name='hidden']) and type='real'] ) or exists( variable[parametertype='instance' and (input='yes' or input='no' and exists(attribute[name='hidden'])) and not(type='real')] )]">
     <admst:text format="// instance parameters\n"/>
   </admst:if>

   <admst:if test="[exists( variable[parametertype='instance' and input='yes' and type='real'])]">
     <admst:text format="// reals\n"/>
     <admst:join select="variable[parametertype='instance' and input='yes' and type='real']" separator=",\n">
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:text format="AdmsSensFadType &amp; "/>
       </admst:if>
       <admst:text format="instancePar_%(name),\n"/>
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:text format="bool "/>
       </admst:if>
       <admst:text format="instancePar_given_%(name)"/>
     </admst:join>
     <admst:variable name="iGeneratedArgs" select="yes" />
   </admst:if>

   <admst:if test="[exists( variable[parametertype='instance' and input='no' and exists(attribute[name='hidden']) and type='real'] )]">
     <admst:if test="[$iGeneratedArgs = 'yes']">
       <admst:text format=",\n"/>
     </admst:if>
     <admst:text format="// real hiddens\n"/>
     <admst:join select="variable[parametertype='instance' and input='no' and exists(attribute[name='hidden']) and type='real']" separator=",\n">
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:text format="AdmsSensFadType &amp; "/>
       </admst:if>
       <admst:text format="instancePar_%(name)"/>
     </admst:join>
     <admst:variable name="iGeneratedArgs" select="yes" />
   </admst:if>

   <admst:if test="[exists( variable[parametertype='instance' and (input='yes' or input='no' and exists(attribute[name='hidden'])) and not(type='real')] )]">
     <admst:text format=",\n"/>
     <admst:text format="// non-reals(including hidden)\n"/>
     <admst:join select="variable[parametertype='instance' and (input='yes' or input='no' and exists(attribute[name='hidden'])) and not(type='real')]" separator=",\n">
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:apply-templates select="." match="verilog2CXXtype"/>
       </admst:if>
       <admst:text format=" instancePar_%(name)"/>
       <admst:if test="[not(exists(attribute[name='hidden']))]">
         <admst:text format=",\n"/>
         <admst:if test="[$globalDeclareVars='yes']">
           <admst:text format="bool "/>
         </admst:if>
         <admst:text format="instancePar_given_%(name)"/>
       </admst:if>
     </admst:join>
     <admst:variable name="iGeneratedArgs" select="yes" />
   </admst:if>

   <admst:if test="[exists( variable[(scope='global_instance') and input='no' and not (exists(attribute[name='hidden']) and type='real')]) or exists( variable[(scope='global_instance') and input='no' and not (exists(attribute[name='hidden'])) and not (type='real')])]">
     <admst:if test="[$iGeneratedArgs = 'yes']">
       <admst:text format=",\n"/>
     </admst:if>
     <admst:text format="// instance variables\n"/>
   </admst:if>
   <admst:if test="[exists( variable[(scope='global_instance') and input='no' and not (exists(attribute[name='hidden']) and type='real')])]">
     <admst:text format="// reals\n"/>
     <admst:join select="variable[(scope='global_instance') and input='no' and not (exists(attribute[name='hidden'])) and type='real']" separator=",\n">
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:text format="AdmsSensFadType &amp; "/>
       </admst:if>
       <admst:text format="instanceVar_%(name)"/>
     </admst:join>
     <admst:variable name="iGeneratedArgs" select="yes" />
   </admst:if>

   <admst:if test="[exists( variable[(scope='global_instance') and input='no' and not (exists(attribute[name='hidden'])) and not (type='real')])]">
     <admst:if test="[$iGeneratedArgs = 'yes']">
       <admst:text format=",\n"/>
     </admst:if>
     <admst:text format="// non-reals\n"/>
     <admst:join select="variable[(scope='global_instance') and input='no' and not (type='real')]" separator=",\n">
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:apply-templates select="." match="verilog2CXXtype"/>
       </admst:if>
       <admst:text format=" instanceVar_%(name)"/>
     </admst:join>
     <admst:variable name="iGeneratedArgs" select="yes" />
   </admst:if>

   <admst:return name="iGeneratedArgs" value="$iGeneratedArgs"/>
 </admst:template>

 <!--
   =================================================================-
   generateModelArgs

   This method, called by generateEvaluateModelEquationsArgs and by
   declarations and calls of evaluateInitialModel,
   centralizes declaration or call for model parameters and model
   variables.

   In this version, we're very specifically emitting declarations JUST
   for sensitivity, not for a general version.
   =================================================================-
 -->
 <admst:template match="generateModelArgs">
   <admst:variable name="iGeneratedArgs" select="no" />
   <admst:if test="[exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes' and type='real']) or exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='no' and exists(attribute[name='hidden']) and type='real']) or exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and (input='yes' or (input='no' and exists(attribute[name='hidden']))) and not (type='real')])]">
     <admst:text format="// model parameters\n"/>
   </admst:if>

   <admst:if test="[exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes' and type='real'])]">
     <admst:text format="// reals\n"/>
     <admst:join select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes' and type='real']" separator=",\n">
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:text format="AdmsSensFadType &amp; "/>
       </admst:if>
       <admst:text format="modelPar_%(name),\n"/>
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:text format="bool "/>
       </admst:if>
       <admst:text format="modelPar_given_%(name)"/>
     </admst:join>
     <admst:variable name="iGeneratedArgs" select="yes" />
   </admst:if>

   <admst:if test="[exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='no' and exists(attribute[name='hidden']) and type='real'])]">
     <admst:if test="[$iGeneratedArgs = 'yes']">
       <admst:text format=",\n"/>
     </admst:if>
     <admst:text format="// real hiddens\n"/>
     <admst:join select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='no' and exists(attribute[name='hidden']) and type='real']" separator=",\n">
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:text format="AdmsSensFadType &amp; "/>
       </admst:if>
       <admst:text format="modelPar_%(name)"/>
     </admst:join>
     <admst:variable name="iGeneratedArgs" select="yes" />
   </admst:if>

   <admst:if test="[exists( variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and (input='yes' or (input='no' and exists(attribute[name='hidden']))) and not (type='real')])]">
     <admst:if test="[$iGeneratedArgs = 'yes']">
       <admst:text format=",\n"/>
     </admst:if>
     <admst:text format="// non-reals (including hidden)\n"/>
     <admst:join select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and (input='yes' or (input='no' and exists(attribute[name='hidden']))) and not (type='real')]" separator=",\n">
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:apply-templates select="." match="verilog2CXXtype"/>
       </admst:if>
       <admst:text format=" modelPar_%(name)"/>
       <admst:if test="[not(exists(attribute[name='hidden']))]">
         <admst:text format=",\n"/>
         <admst:if test="[$globalDeclareVars='yes']">
           <admst:text format="bool "/>
         </admst:if>
         <admst:text format="modelPar_given_%(name)"/>
       </admst:if>
     </admst:join>
     <admst:variable name="iGeneratedArgs" select="yes" />
   </admst:if>

   <admst:if test="[exists( variable[(scope='global_model') and input='no' and not (exists(attribute[name='hidden'])) and type='real']) or exists( variable[(scope='global_model') and input='no' and not (type='real')])]">
     <admst:text format="// model variables\n"/>
   </admst:if>
   <admst:if test="[exists( variable[(scope='global_model') and input='no' and not (exists(attribute[name='hidden'])) and type='real'])]">
     <admst:if test="[$iGeneratedArgs = 'yes']">
       <admst:text format=",\n"/>
     </admst:if>
     <admst:variable name="iGeneratedArgs" select="yes" />
     <admst:text format="// reals\n"/>
     <admst:join select="variable[(scope='global_model') and input='no' and not (exists(attribute[name='hidden'])) and type='real']" separator=",\n">
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:text format="AdmsSensFadType &amp; "/>
       </admst:if>
       <admst:text format="modelVar_%(name)"/>
     </admst:join>
     <admst:variable name="iGeneratedArgs" select="yes" />
   </admst:if>

   <admst:if test="[exists( variable[(scope='global_model') and input='no' and not (type='real')])]">
     <admst:if test="[$iGeneratedArgs = 'yes']">
       <admst:text format=",\n"/>
     </admst:if>
     <admst:text format="// non-reals\n"/>
     <admst:join select="variable[(scope='global_model') and input='no' and not (type='real')]" separator=",\n">
       <admst:if test="[$globalDeclareVars='yes']">
         <admst:apply-templates select="." match="verilog2CXXtype"/>
       </admst:if>
       <admst:text format=" modelVar_%(name)"/>
     </admst:join>
     <admst:variable name="iGeneratedArgs" select="yes" />
   </admst:if>

   <admst:return name="iGeneratedArgs" value="$iGeneratedArgs"/>
 </admst:template>

</admst>
